'use strict';

var assert = require('assert');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var tvdutil = require('tvdutil');
var _ = require('lodash');

//	TODO:
//	 - Check field modules in getWebAPI
//	 - Check webApi name <=> api

function resolvID( apiID ) {
	if (apiID.indexOf('.') === -1) {
		return 'ar.edu.unlp.info.lifia.tvd.' + apiID;
	}
	return apiID;
}

function callMethod( srv, method, evt, failOnSignal ) {
	if (method.isSignal) {
		if (failOnSignal) {
			throw new Error('Signals not allowed');
		}

		//	Signal call
		var argsSignal = _.cloneDeep(evt.params);
		argsSignal.push(function () {
			evt.resultCB({
				data: Array.prototype.slice.call(arguments),
				isSignal: true,
			});
		});
		method.apply( srv, argsSignal );

		// Save unregister function binded to eventName and callback
		// The check is necesary because once signals are unregistered automatically
		if (method.unregisterMethod && evt.unregisterSignal) {
			evt.unregisterSignal(function() {
				method.unregisterMethod.apply(srv, argsSignal);
			});
		}
	}
	else if (method.isAsync) {
		//	Async call
		var argsAsync = _.cloneDeep(evt.params);
		argsAsync.push(function() {
			var args = Array.prototype.slice.call(arguments);
			var argc = args.length;
			evt.resultCB({
				data: (argc > 1) ? args.slice(1, argc) : undefined,
				error: args[0],
				isSignal: false,
			});
		});
		method.apply( srv, argsAsync );
	}
	else {
		//	Sync: Only call to result callback if something is returned
		var res = method.apply(srv, evt.params);
		if (res !== undefined) {
			evt.resultCB({
				data: [res],
				isSignal: false,
			});
		} else {
			// Call callback to notify that the api-call run successfully
			evt.resultCB({isSignal: false});
		}
	}
}

function Registry() {
	var _apis = {};
	var _events = new EventEmitter();

	var self = {};

	function validateMethods( apiID, api, webAPI, key ) {
		let methods = webAPI[key];
		if (methods) {
			if (!_.isArray(methods)) {
				throw tvdutil.warnErr( 'Service', 'getWebAPI must return a object with %s methods as array: apiID=%s', key, apiID );
			}

			methods.forEach(function(method) {
				if (!_.get(api, method)) {
					throw tvdutil.warnErr( 'Service', 'Web exported methods must exists: apiID=%s, method=%s', apiID, method );
				}
			});
		}
	}

	function isPrivateAllowed( apiID, secOptions ) {
		if (secOptions.all) {
			return true;
		}

		if (!secOptions.api || !_.isArray(secOptions.api)) {
			return false;
		}

		return secOptions.api.findIndex( (id) => id === apiID ) >= 0;
	}

	function getMethods( api, privateAllowed ) {
		let webApi = api.getWebAPI();
		assert(webApi);

		let exports = [];

		let publicMethods = webApi['public'];
		let privateMethods = webApi['private'];

		if (!publicMethods && !privateMethods) {
			Array.prototype.push.apply(exports, _.without(_.functions(api),'getWebAPI'));
		}
		else {
			if (publicMethods) {
				Array.prototype.push.apply(exports, publicMethods);
			}

			if (privateMethods && privateAllowed) {
				Array.prototype.push.apply(exports, privateMethods);
			}
		}

		if (webApi.modules) {
			Array.prototype.push.apply(exports, webApi.modules.forEach( (m) => getMethods( api[m], privateAllowed ) ));
		}

		return exports;
	}

	function addWebApi( res, apiID, api, sec, optName ) {
		if (api && api.getWebAPI) {
			let webApi = api.getWebAPI();

			let apiName = optName ? (optName + '.') : '';
			apiName += webApi.name;

			let tmp = {
				name: apiName,
				id: apiID,
				exports: getMethods(api,isPrivateAllowed(apiID,sec))
			};

			res.push( tmp );

			if (webApi.modules) {	//	TODO: Check on reg.put
				webApi.modules.forEach( (m) => addWebApi( res, apiID, api[m], sec, webApi.name ) );
			}
		}
	}

	//	Events
	tvdutil.forwardEventEmitter(self,_events);
	self.on.isSignal = true;
	self.on.unregisterMethod = self.removeListener;

	self.has = function(apiID) {
		return resolvID(apiID) in _apis;
	};

	self.get = function(apiID) {
		var id = resolvID(apiID);
		return _apis[id];
	};

	self.put = function(apiID, api) {
		if (!_.isObject(api)) {
			throw tvdutil.warnErr( 'Registry', 'Api must be a object: apiID=%s', apiID );
		}

		//	Check API is a function
		if (api.getWebAPI) {
			if (!_.isFunction(api.getWebAPI)) {
				throw tvdutil.warnErr( 'Registry', 'getWebAPI must be a function: apiID=%s', apiID );
			}

			//	Check web API name
			var webApi = api.getWebAPI();
			if (!_.isString(webApi.name)) {
				throw tvdutil.warnErr( 'Service', 'getWebAPI must return a object with a name property: apiID=%s', apiID );
			}

			//	Validate methods
			validateMethods( apiID, api, webApi, 'public' );
			validateMethods( apiID, api, webApi, 'private' );
		}

		if (self.has(apiID)) {
			throw tvdutil.warnErr( 'Registry', 'Api already exists: apiID=%s', apiID );
		}

		var id = resolvID(apiID);
		_apis[id] = api;
		_events.emit( 'added', id );
	};

	self.remove = function(apiID) {
		var id = resolvID(apiID);
		_events.emit( 'remove', id );
		delete _apis[id];
	};

	self.swap = function( apiID, newApi ) {
		var id = resolvID(apiID);
		var old = _apis[id];
		_apis[id] = newApi;
		return old;
	};

	self.getWebApis = function( apis, security ) {
		let sec = security || { all: false };
		var res = [];
		apis.forEach(function(apiID) {
			let api = self.get(apiID);
			addWebApi( res, apiID, api, sec );
		});
		return res;
	};

	self.runAPI = function( evt ) {
		try {
			assert(evt.appID, 'appID not defined');
			assert(evt.serviceID,'serviceID not defined');
			assert(evt.method,'method not defined');
			assert(evt.resultCB,'resultCB not defined');

			evt.failOnSignal = evt.failOnSignal || false;
			let sec = evt.security || { all:false};

			log.silly('Registry', 'Service API call: evt=%j', evt );

			//	Check if service exists
			var srv = self.get( evt.serviceID );
			if (!srv) {
				throw new Error('Service not found');
			}

			//	Check if service has some API eported
			if (!srv.getWebAPI) {
				throw new Error('Service not exported');
			}

			//	Get all web apis
			let webApis = self.getWebApis( [evt.serviceID], sec );
			assert(webApis.length >= 0,'No web apis availables');	//	Checked in self.put

			let webApi;
			let api;
			if (webApis.length > 1) {
				if (!evt.apiName) {
					throw new Error('Invalid parameter apiName');
				}

				//	Check if service has the api
				webApi = webApis.find( (w) => w.name === evt.apiName );
				if (!webApi) {
					throw new Error('Service API not exported');
				}

				let index = evt.apiName.indexOf( '.' );
				if (index >= 0) {
					api = srv[evt.apiName.substr(index+1)];
				}
				else {
					api = srv;
				}
			}
			else {
				webApi = webApis[0];
				api = srv;
			}
			assert(webApi,'No webApi available');
			assert(api,'No api available');

			//	Check if method is a function in the api exported
			if (!_.includes(webApi.exports,evt.method)) {
				throw new Error('Method not exists');
			}

			//	Get method
			let method = api[evt.method];
			assert(method,'No method available');	//	checked in self.put && previous check

			//	Make sure evt params is always an array
			if (evt.params === undefined) {
				evt.params = [];
			}

			//	Insert id of the app that make the api call if necesary
			if (method.insertId) {
				evt.params.unshift(evt.appID);
			}

			//	Call API method
			callMethod(api, method, evt, evt.failOnSignal);
		}
		catch(err) {
			var msg = util.format( 'Registry API call cannot be processed; appID=%s, apiID=%s, apiName=%s, method=%s, err=%s',
								   evt.appID, evt.serviceID, evt.apiName, evt.method, err.message );
			log.error( 'Registry', msg );
			evt.resultCB({error:new Error(msg), isSignal:false});
			return;
		}
	};

	return Object.freeze(self);
}

module.exports = Registry;
