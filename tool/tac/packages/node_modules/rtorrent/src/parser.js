'use strict';

var assert = require('assert');
var Sax = require('sax');

function Parser() {
	var _marks = [];
	var _stack = [];
	var _data = [];
	var _type = null;
	var _responseType = null;
	var _onDeserializeCB = null;

	//	Setup Sax parser
	var _sax = Sax.createStream();
	_sax.on('opentag',  onOpentag );
	_sax.on('closetag', onClosetag );
	_sax.on('text',     onText );
	_sax.on('end',      onDone );
	_sax.on('error',    onError );

	//	Aux
	function notify( err, val ) {
		if (_onDeserializeCB) {
			_onDeserializeCB( err, val );
			_onDeserializeCB = null;
		}
	}

	function onError( err ) {
		log.error( 'parser', 'Error: err=%s', err.message );
		notify( err );
	}

	function createFault(fault) {
		var error = new Error('XML-RPC fault' + (fault.faultString ? ': ' + fault.faultString : ''));
		error.code = fault.faultCode;
		return error;
	}

	function onDone() {
		if (_type === null || _marks.length) {
			onError( new Error('Invalid XML-RPC message') );
		}
		else if (_responseType === 'fault') {
			onError( createFault(_stack[0]) );
		}
		else {
			assert(_responseType === 'params');
			notify( undefined, _stack[0] );
		}
	}

	function onOpentag(node) {
		//log.silly( 'parser', 'On open tag: name=%s', node.name );
		if (node.name === 'ARRAY' || node.name === 'STRUCT') {
			_marks.push(_stack.length);
		}
		_data = [];
	}

	function onText(text) {
		_data.push(text);
	}

	function onClosetag(el) {
		var data = _data.join('');
		//log.silly( 'parser', 'On close tag: data=%s, el=%j', data, el );
		try {
			switch(el) {
			case 'BOOLEAN':
				if (data === '1') {
					_stack.push(true);
				}
				else if (data === '0') {
					_stack.push(false);
				}
				else {
					throw new Error('Illegal boolean value \'' + data + '\'');
				}
				break;
			case 'INT':
			case 'I4':
				var valueInt = parseInt(data, 10);
				if (isNaN(valueInt)) {
					throw new Error('Expected an integer value but got \'' + data + '\'');
				}
				_stack.push(valueInt);
				break;
			case 'I8':
				if (!/^-?\d+$/.test(data)) {
					throw new Error('Expected an integer (I8) value but got \'' + data + '\'');
				}
				endString(data);
				break;
			case 'DOUBLE':
				var valueFloat = parseFloat(data);
				if (isNaN(valueFloat)) {
					throw new Error('Expected a double value but got \'' + data + '\'');
				}
				_stack.push(valueFloat);
				break;
			case 'STRING':
			case 'NAME':
				endString(data);
				break;
			case 'ARRAY':
				var mark = _marks.pop();
				_stack.splice(mark, _stack.length - mark, _stack.slice(mark));
				break;
			case 'STRUCT':
				endStruct(data);
				break;
			case 'BASE64':
				endBase64(data);
				break;
			case 'VALUE':
				break;
			case 'PARAMS':
				_responseType = 'params';
				break;
			case 'FAULT':
				_responseType = 'fault';
				break;
			case 'METHODRESPONSE':
				endMethodResponse(data);
				break;
			case 'METHODCALL':
				endMethodCall(data);
				break;
			case 'NIL':
				_stack.push(null);
				break;
			case 'DATA':
			case 'PARAM':
			case 'MEMBER':
				// Ignored by design
				break;
			default:
				onError( new Error('Unknown XML-RPC tag \'' + el + '\'') );
				break;
			}
		}
		catch (e) {
			onError(e);
		}
	}

	function endString(data) {
		_stack.push(data);
	}

	function endStruct() {
		var mark = _marks.pop();
		var struct = {};
		var items = _stack.slice(mark);
		for (var i=0; i < items.length; i+=2) {
			struct[items[i]] = items[i + 1];
		}
		_stack.splice(mark, _stack.length - mark, struct);
	}

	function endBase64(data) {
		var buffer = new Buffer(data, 'base64');
		_stack.push(buffer);
	}

	function endMethodResponse() {
		_type = 'methodresponse';
	}

	function endMethodCall() {
		_type = 'methodcall';
	}

	//	API
	var self = {};
	self.deserialize = function( stream, cb ) {
		assert(_sax);
		assert(cb);

		stream.setEncoding('utf8');
		stream.on('error', onError );
		stream.pipe(_sax);

		_onDeserializeCB = cb;
	};

	return self;
}

module.exports = Parser;

