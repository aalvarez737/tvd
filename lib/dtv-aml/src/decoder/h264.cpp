#include "packet.h"
//#include "codec/codec.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HDR_BUF_SIZE 1024
#define BUFFER_SIZE 2048

namespace aml {
namespace h264 {

static int check_size_in_buffer(unsigned char *p, int len) {
	unsigned int size;
	unsigned char *q = p;
	while ((q + 4) < (p + len)) {
		size = (*q << 24) | (*(q + 1) << 16) | (*(q + 2) << 8) | (*(q + 3));
		if (size & 0xff000000) {
			return 0;
		}

		if (q + size + 4 == p + len) {
			return 1;
		}

		q += size + 4;
	}
	return 0;
}

static int check_size_in_buffer2(unsigned char *p, int len) {
	unsigned int size;
	unsigned char *q = p;
	while ((q + 2) < (p + len)) {
		size = (*q << 8) | (*(q + 1));

		if (q + size + 2 == p + len) {
			return 1;
		}

		q += size + 2;
	}
	return 0;
}

static int check_size_in_buffer3(unsigned char *p, int len) {
	unsigned int size;
	unsigned char *q = p;
	while ((q + 3) < (p + len)) {
		size = (*q << 16) | (*(q + 1) << 8) | (*(q + 2));

		if (q + size + 3 == p + len) {
			return 1;
		}

		q += size + 3;
	}
	return 0;
}

// static int write_end_header(play_para_t *para) {	TODO
// 	unsigned char end_header[] = {
// 		0x00, 0x00, 0x00, 0x01, 0x06, 0x05, 0xff, 0xe4, 0xdc, 0x45, 0xe9, 0xbd, 0xe6, 0xd9, 0x48, 0xb7,
// 		0x96, 0x2c, 0xd8, 0x20, 0xd9, 0x23, 0xee, 0xef, 0x78, 0x32, 0x36, 0x34, 0x20, 0x2d, 0x20, 0x63,
// 		0x6f, 0x72, 0x65, 0x20, 0x36, 0x37, 0x20, 0x72, 0x31, 0x31, 0x33, 0x30, 0x20, 0x38, 0x34, 0x37,
// 		0x35, 0x39, 0x37, 0x37, 0x20, 0x2d, 0x20, 0x48, 0x2e, 0x32, 0x36, 0x34, 0x2f, 0x4d, 0x50, 0x45,
// 		0x47, 0x2d, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x20, 0x2d, 0x20,
// 		0x43, 0x6f, 0x70, 0x79, 0x6c, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x2d, 0x32, 0x30,
// 		0x30, 0x39, 0x20, 0x2d, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e,
// 		0x76, 0x69, 0x64, 0x65, 0x6f, 0x6c, 0x61, 0x6e, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x78, 0x32, 0x36,
// 		0x34, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x20, 0x2d, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
// 		0x3a, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63, 0x3d, 0x31, 0x20, 0x72, 0x65, 0x66, 0x3d, 0x31, 0x20,
// 		0x64, 0x65, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x3d, 0x31, 0x3a, 0x30, 0x3a, 0x30, 0x20, 0x61, 0x6e,
// 		0x61, 0x6c, 0x79, 0x73, 0x65, 0x3d, 0x30, 0x78, 0x31, 0x3a, 0x30, 0x78, 0x31, 0x31, 0x31, 0x20,
// 		0x6d, 0x65, 0x3d, 0x68, 0x65, 0x78, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x65, 0x3d, 0x36, 0x20, 0x70,
// 		0x73, 0x79, 0x5f, 0x72, 0x64, 0x3d, 0x31, 0x2e, 0x30, 0x3a, 0x30, 0x2e, 0x30, 0x20, 0x6d, 0x69,
// 		0x78, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x66, 0x3d, 0x30, 0x20, 0x6d, 0x65, 0x5f, 0x72, 0x61, 0x6e,
// 		0x67, 0x65, 0x3d, 0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61, 0x5f, 0x6d, 0x65, 0x3d,
// 		0x31, 0x20, 0x74, 0x72, 0x65, 0x6c, 0x6c, 0x69, 0x73, 0x3d, 0x30, 0x20, 0x38, 0x78, 0x38, 0x64,
// 		0x63, 0x74, 0x3d, 0x30, 0x20, 0x63, 0x71, 0x6d, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64, 0x7a,
// 		0x6f, 0x6e, 0x65, 0x3d, 0x32, 0x31, 0x2c, 0x31, 0x31, 0x20, 0x63, 0x68, 0x72, 0x6f, 0x6d, 0x61,
// 		0x5f, 0x71, 0x70, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x3d, 0x2d, 0x32, 0x20, 0x74, 0x68,
// 		0x72, 0x65, 0x61, 0x64, 0x73, 0x3d, 0x31, 0x20, 0x6e, 0x72, 0x3d, 0x30, 0x20, 0x64, 0x65, 0x63,
// 		0x69, 0x6d, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x20, 0x6d, 0x62, 0x61, 0x66, 0x66, 0x3d, 0x30, 0x20,
// 		0x62, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x3d, 0x30, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74,
// 		0x3d, 0x32, 0x35, 0x30, 0x20, 0x6b, 0x65, 0x79, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x3d,
// 		0x32, 0x35, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x63, 0x75, 0x74, 0x3d, 0x34, 0x30, 0x20, 0x72,
// 		0x63, 0x3d, 0x61, 0x62, 0x72, 0x20, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x3d, 0x31, 0x30,
// 		0x20, 0x72, 0x61, 0x74, 0x65, 0x74, 0x6f, 0x6c, 0x3d, 0x31, 0x2e, 0x30, 0x20, 0x71, 0x63, 0x6f,
// 		0x6d, 0x70, 0x3d, 0x30, 0x2e, 0x36, 0x30, 0x20, 0x71, 0x70, 0x6d, 0x69, 0x6e, 0x3d, 0x31, 0x30,
// 		0x20, 0x71, 0x70, 0x6d, 0x61, 0x78, 0x3d, 0x35, 0x31, 0x20, 0x71, 0x70, 0x73, 0x74, 0x65, 0x70,
// 		0x3d, 0x34, 0x20, 0x69, 0x70, 0x5f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x3d, 0x31, 0x2e, 0x34, 0x30,
// 		0x20, 0x61, 0x71, 0x3d, 0x31, 0x3a, 0x31, 0x2e, 0x30, 0x30, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01,
// 		0x67, 0x4d, 0x40, 0x0a, 0x9a, 0x74, 0xf4, 0x20, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x06,
// 		0x51, 0xe2, 0x44, 0xd4, 0x00, 0x00, 0x00, 0x01, 0x68, 0xee, 0x32, 0xc8, 0x00, 0x00, 0x00, 0x01,
// 		0x65, 0x88, 0x80, 0x20, 0x00, 0x08, 0x7f, 0xea, 0x6a, 0xe2, 0x99, 0xb6, 0x57, 0xae, 0x49, 0x30,
// 		0xf5, 0xfe, 0x5e, 0x46, 0x0b, 0x72, 0x44, 0xc4, 0xe1, 0xfc, 0x62, 0xda, 0xf1, 0xfb, 0xa2, 0xdb,
// 		0xd6, 0xbe, 0x5c, 0xd7, 0x24, 0xa3, 0xf5, 0xb9, 0x2f, 0x57, 0x16, 0x49, 0x75, 0x47, 0x77, 0x09,
// 		0x5c, 0xa1, 0xb4, 0xc3, 0x4f, 0x60, 0x2b, 0xb0, 0x0c, 0xc8, 0xd6, 0x66, 0xba, 0x9b, 0x82, 0x29,
// 		0x33, 0x92, 0x26, 0x99, 0x31, 0x1c, 0x7f, 0x9b
// 	};
// 	int header_size = sizeof(end_header) / sizeof(unsigned char);

// 	unsigned char *tmp_data = malloc(1024);
// 	if (!tmp_data) {
// 		return false;
// 	}
// 	memset(tmp_data, 0, 1024);
// 	memcpy(tmp_data, &end_header, header_size);
// 	ret = codec_write(para->vcodec, (void *)tmp_data, 1024);
// 	free(tmp_data);

// 	return true;
// }

// size = pkt->data_size;
// data = pkt->data;
bool updateFrame( Packet *pkt ) {
	int size = pkt->size;
	unsigned char *data = pkt->data;
	unsigned char *p = data;

	if (!p) {
		printf( "[aml] Update frame error: Invalid data!\n" );
		return false;
	}

	int nalsize=0;
	if (check_size_in_buffer(p, size)) {
		while ((p + 4) < (data + size)) {
			nalsize = (*p << 24) | (*(p + 1) << 16) | (*(p + 2) << 8) | (*(p + 3));
			*p = 0;
			*(p + 1) = 0;
			*(p + 2) = 0;
			*(p + 3) = 1;
			p += (nalsize + 4);
		}
		printf( "[%s:%d] Using size: nalsize=%08x!\n", __FUNCTION__, __LINE__, nalsize );
		return true;
	} else if (check_size_in_buffer3(p, size)) {
		while ((p + 3) < (data + size)) {
			nalsize = (*p << 16) | (*(p + 1) << 8) | (*(p + 2));
			*p = 0;
			*(p + 1) = 0;
			*(p + 2) = 1;
			p += (nalsize + 3);
		}
		printf( "[%s:%d] Using size3!\n", __FUNCTION__, __LINE__ );
		return true;
	} else if (check_size_in_buffer2(p, size)) {
		unsigned char *new_data;
		int new_len = 0;

		new_data = (unsigned char *)malloc(size + 2 * 1024);
		if (!new_data) {
			printf( "[%s:%d] Cannot alloc memory!\n", __FUNCTION__, __LINE__ );
			return false;
		}

		while ((p + 2) < (data + size)) {
			nalsize = (*p << 8) | (*(p + 1));
			*(new_data + new_len) = 0;
			*(new_data + new_len + 1) = 0;
			*(new_data + new_len + 2) = 0;
			*(new_data + new_len + 3) = 1;
			memcpy(new_data + new_len + 4, p + 2, nalsize);
			p += (nalsize + 2);
			new_len += nalsize + 4;
		}

		pkt->assign( new_data, new_len, size + 2 * 1024, true );
		printf( "[%s:%d] Using size2!\n", __FUNCTION__, __LINE__ );
		return true;
	}
	else {
		int alloc_len = size + 4 * 1024;
		unsigned char *new_data = (unsigned char *)malloc(alloc_len);
		if (!new_data) {
			printf( "[%s:%d] Cannot alloc memory!\n", __FUNCTION__, __LINE__ );
			return false;
		}

		//	Skip:  00 41 -> 41
		// p++;
		// size--;

		//	Add 00 00 00 01
		*(new_data) = 0;
		*(new_data + 1) = 0;
		*(new_data + 2) = 0;
		*(new_data + 3) = 1;

		//	Copy nal
		memcpy(new_data + 4, p, size);
		//	Assign to packet
		pkt->assign( new_data, size+4, alloc_len, true );

		//printf( "[%s:%d] chrome!\n", __FUNCTION__, __LINE__ );
		return true;
	}

	printf( "[%s:%d] No size!\n", __FUNCTION__, __LINE__ );
	return false;
}

//	player_hwdec.c -> h264_add_header
bool updateHeader( Packet *info, Packet *pkt ) {
	unsigned char *buf = info->data;
	int size = info->size;
	unsigned char* p = info->data;;

	if ((p[0] == 0 && p[1] == 0 && p[2] == 0 && p[3] == 1) && size < HDR_BUF_SIZE) {
		printf("[%s:%d] add 264 header in stream before header len=%d\n", __FUNCTION__, __LINE__, size);
		pkt->copy(buf, size);
		pkt->size = size;
		return true;
	}

	if (size < 10) {
		printf("[%s:%d] avcC too short\n", __FUNCTION__, __LINE__ );
		return false;
	}

	if (*p != 1) {
		printf("[%s:%d] Unkonwn avcC version %d\n", __FUNCTION__, __LINE__, *p );
		return false;
	}

	if (!pkt->alloc(HDR_BUF_SIZE)) {
		printf("[%s:%d] Cannot alloc buffer size %d\n", __FUNCTION__, __LINE__, *p );
		return false;
	}

	char nal_start_code[] = {0x0, 0x0, 0x0, 0x1};
	int nalsize;
	int tmpi;
	int header_len = 0;
	unsigned char* buffer = pkt->data;

	int cnt = *(p + 5) & 0x1f; //number of sps
	printf("[%s:%d] number of sps :%d\n", __FUNCTION__, __LINE__, cnt );
	p += 6;
	for (tmpi = 0; tmpi < cnt; tmpi++) {
		nalsize = (*p << 8) | (*(p + 1));
		memcpy(&(buffer[header_len]), nal_start_code, 4);
		header_len += 4;
		memcpy(&(buffer[header_len]), p + 2, nalsize);
		header_len += nalsize;
		p += (nalsize + 2);
	}

	cnt = *(p++); //Number of pps
	printf("[%s:%d] number of pps :%d\n", __FUNCTION__, __LINE__, cnt );
	for (tmpi = 0; tmpi < cnt; tmpi++) {
		nalsize = (*p << 8) | (*(p + 1));
		memcpy(&(buffer[header_len]), nal_start_code, 4);
		header_len += 4;
		memcpy(&(buffer[header_len]), p + 2, nalsize);
		header_len += nalsize;
		p += (nalsize + 2);
	}
	if (header_len >= HDR_BUF_SIZE) {
		printf("[%s:%d] header_len %d is larger than max length\n", __FUNCTION__, __LINE__, header_len );
		return false;
	}

	pkt->size = header_len;
	return true;
}

}
}


