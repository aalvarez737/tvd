'use strict';

var util = require('util');
var assert = require('assert');
var url = require('url');
var crypto = require("crypto");
var path = require('path');
var EventEmitter = require('events').EventEmitter;
var http = require('http');
var https = require('https');
var _ = require('lodash');
var bPromise = require('bluebird');
var fs = bPromise.promisifyAll( require('fs') );
var mktemp = bPromise.promisifyAll( require('mktemp') );
var ChildProc = require('child_process');
var log = require('npmlog');

function setupLog( level, cfg ) {
	//	Register log global
	global.log = log;
	log.level = level;

	if (cfg) {
		try {
			log.prefixLevel = JSON.parse(fs.readFileSync(cfg));
			log.info( 'tvdutil', 'Loaded log configuration from %s', cfg );
		} catch(err) {
			if (err.code !== 'ENOENT') {
				log.warn( 'tvdutil', 'Cannot load log configuration: file=%s, err=%s', cfg, err.message );
			}
		}
	}
}

function isFile( path ) {
	try {
		return fs.statSync(path).isFile();
	} catch( error ) {
		return false;
	}
}

function isDirectory( path ) {
	try {
		return fs.statSync(path).isDirectory();
	} catch( error ) {
		return false;
	}
}

function isHidden(path) {
	return (/(^|\/)\.[^\/\.]/g).test(path);
}

function ensureDir( p ) {
	if (!isDirectory(p)) {
		fs.mkdirSync( p );
	}
}

function cleanDir( parent ) {
	var st;
	try {
		st = fs.statSync(parent);
	} catch(err) {}

	if (!st) {
		fs.mkdirSync( parent );
	}
	else if (st.isFile()) {
		fs.unlinkSync( parent );
		fs.mkdirSync( parent );
	}
	else {
		fs.readdirSync(parent).forEach(function(file) {
			removeTreeSync( path.join(parent,file) );
		});
	}
}

function removeTreeSync(parent) {
	if(fs.lstatSync(parent).isDirectory()) {
		fs.readdirSync(parent).forEach(function(file) {
			removeTreeSync( path.join(parent,file) );
		});
		fs.rmdirSync( parent );
	} else { // delete file
		fs.unlinkSync( parent );
	}
}

function removeTreeImpl(parent) {
	return fs.statAsync(parent).then(function(stat) {
		if (stat.isDirectory()) {
			return fs.readdirAsync(parent).map(function (node) {
				var file = path.join(parent, node);
				return removeTreeAsync( file );
			}).all().then(function() {
				return fs.rmdirAsync(parent);
			});
		} else {
			return fs.unlinkAsync(parent);
		}
	});
}

function removeTree( parent, cb ) {
	removeTreeImpl(parent).
		then(function() {
			cb();
		}).
		catch(function(err) {
			cb(err);
		});
}

function removeTreeAsync( parent ) {
	return removeTreeImpl(parent);
}

function emitThen(emitter,event) {
	var args = Array.prototype.slice.call(arguments, 2);
	return bPromise
		.bind(emitter)
		.return(emitter)
		.call('listeners', event)
		.map(function (listener) {
			if (listener.isAsync) {
				return new bPromise(function(resolv,reject) {
					var params = _.cloneDeep(args);
					params.push( function(err) {
						if (err) {
							reject(err);
						}
						else {
							resolv();
						}
					});
					return listener.apply(this,params);
				});
			}
			else {
				return listener.apply(this, args);
			}
		})
		.return(null);
}

function diskSpace( p, cb ) {
	assert(cb);
	ChildProc.exec("df -k '" + p + "'", function(error, stdout) {
		if (error) {
			cb(error);
		}
		else {
			var lines = stdout.trim().split("\n");
			var str_disk_info = lines[lines.length - 1].replace( /[\s\n\r]+/g,' ');
			var disk_info = str_disk_info.split(' ');

			var st = {
				"total": disk_info[1] * 1024,
				"free": disk_info[3] * 1024
			};
			cb(undefined, st);
		}
	});
}

function isValidURL( url ) {
	return (url.protocol !== undefined) && (url.protocol === 'http:' || url.protocol == 'https:');
}

function furl_checkSignature( param ) {
	return new bPromise( function(resolv, reject) {
		if (param.md5 === undefined) {
			resolv(param);
		}
		else {
			var hash = crypto.createHash("md5");
			var stream = fs.createReadStream( param.fileOutput );
			stream.on('data', function (data) {
				hash.update(data, 'utf8');
			});
			stream.on('end', function () {
				if (hash.digest('hex') == param.md5) {
					resolv(param);
				}
				else {
					reject( new Error('Signature error') );
				}
			});
			stream.on('error', function(err) {
				reject(err);
			});
		}
	});
}

function furl_checkSize( param ) {
	if (param.size !== undefined) {
		return fs.statAsync(param.fileOutput)
			.then(function(stats) {
				if (stats.size == param.size) {
					return param;
				}
				else {
					throw new Error( 'Downloaded file differ in size' );
				}
			});
	}
	return param;
}

function furl_fetch( param ) {
	return new bPromise(function(resolve,reject) {
		var params = [
			'--progress=dot',
			'-O',
			param.fileOutput,param.url
		];
		if (param.user && param.password) {
			params.push( '--user' );
			params.push( param.user );
			params.push( '--password' );
			params.push( param.password );
		}
		var wget = ChildProc.spawn('wget', params );
			var re = /[\s\S]* ([0-9]+)%[\s\S]*/g;
			wget.stderr.on('data', function (data) {
				if (param.progress !== undefined) {
					var data_str = data.toString('utf8');
					if (data_str.match( re ) !== null) {
						var progress = parseInt(data_str.replace( re, '$1'));
						param.progress(progress);
					}
				}
			});
		wget.on('close', function(exitCode) {
			if (!exitCode) {
				if (param.progress !== undefined) {
					param.progress(100);
				}
				resolve(param);
			}
			else {
				reject( new Error(util.format('Cannot fetch URL: url=%s',param.url)) );
			}
		});
		wget.on('error', function(err) {
			reject( err );
		});
	});
}

function furl_checkSpace( param ) {
	//	Check disk space
	return new bPromise(function(resolve,reject) {
		if (param.size !== undefined) {
			diskSpace( path.dirname(param.fileOutput), function(err,diskStats) {
				if (err) {
					reject(err);
				}
				else {
					var grantFreeDiskSpace = (param.grantFreeDiskSpace === undefined) ? (1024*1024*200) : param.grantFreeDiskSpace;
 					if ((diskStats.free-param.size) > grantFreeDiskSpace) {
						resolve(param);
					}
					else {
						reject( new Error(util.format('Not enough free disk space: need=%d, free=%d', param.size, diskStats.free)) );
					}
				}
			});
		}
		else {
			resolve(param);
		}
	});
}

function fetchURLAsync( options ) {
	assert(options.url);
	assert(options.fileOutput);

	return furl_checkSpace(options)
		.then(furl_fetch)
		.then(furl_checkSignature)
		.then(furl_checkSize)
		.catch(function(err) {
			return fs.unlinkAsync( options.fileOutput )
				.finally(function() {
					throw err;
				});
		});
}

function fetchURL( options, cb ) {
	fetchURLAsync( options )
		.then(function() {
			cb();
		}, function(err) {
			cb(err);
		});
}

function doRequest( options, callback ) {
	assert(options.url);
	assert(options.method);
	var oURL = url.parse(options.url);
	if (isValidURL(oURL)) {
		var dataString = options.data ? JSON.stringify(options.data) : undefined;

		var opts = {
			hostname: oURL.hostname,
			port: oURL.port,
			path: oURL.path,
			method: options.method,
			headers: {
				'Content-Type': 'application/json',
				'Content-Length': dataString ? Buffer.byteLength(dataString) : 0
			}
		};

		var response = {};
		var rawData = '';
		response.data = null;
		response.statusCode = 0;
		var requestImpl;

		if (options.secure) {
			requestImpl = https.request;
			opts.rejectUnauthorized = false;
		}
		else {
			requestImpl = http.request;
		}
		var req = requestImpl(opts, function(res) {
			response.statusCode = res.statusCode;

			//	On data, add to response
			res.on('data', function(chunk) {
				rawData += chunk;
			});

			//	On end, call to callback
			res.on('end', function() {
				var error;
				var contentType = res.headers['content-type'];
				if (rawData && (typeof contentType === 'string') && contentType.indexOf('application/json') >= 0) {
					//	JSON value
					try {
						response.data = JSON.parse( rawData );
					} catch(err) {
						error = err;
					}
				}
				else {
					response.data = rawData;
				}

				callback(error,response);
			});
		});

		//	Handle error
		req.on('error', callback );
		if (dataString) {
			req.write(dataString);
		}
		req.end();
	} else {
		callback(new Error(util.format('Malformed url=%s', options.url)));
	}
}

function doRequestAsync( opts ) {
	return new bPromise(function(resolve,reject) {
		doRequest( opts, function(err,res) {
			if (err) {
				reject(err);
			}
			else {
				resolve(res);
			}
		});
	});
}

function findFiles( opts ) {
	let level = (opts.level === undefined) ? -1 : opts.level;

	return fs.readdirAsync( opts.root )
		.map(function(entry) {
			let curPath = path.join(opts.root,entry);
			return fs.statAsync( curPath )
				.then(function (stats) {
					let info = {
						absPath: curPath,
						entry: entry,
						stats: stats
					};
					return opts.cbEntry( info )
						.then(function() {
							if (stats.isDirectory()) {
								if (level === -1 || level > 0) {
									let tmpOpts = {
										root: curPath,
										level: (level === -1) ? -1 : level-1,
										cbEntry: opts.cbEntry,
										cbEnd: opts.cbEnd
									};
									return findFiles( tmpOpts );
								}
							}
						});
				});
		})
		.then( opts.cbEnd );
}

function spawnTool( opts ) {
	var dest = path.join( opts.workDir,'tmp.XXXXXXXX');
	return mktemp.createDirAsync( dest )
		.then(function(tmpDir) {
			return new bPromise(function(resolve,reject) {
				function clean(err) {
					return removeTreeAsync(tmpDir)
						.finally(function() {
							reject(err);
						});
				}

				var exe = ChildProc.spawn( opts.tool, opts.getParams(tmpDir) );
				exe.on('close', function(exitCode) {
					if (exitCode !== 0) {
						clean(warnErr( opts.tool, 'Error processing tool: opts=%j', opts ));
					}
					else {
						resolve(tmpDir);
					}
				});
				exe.on('error', function(err) {
					clean(warnErr( opts.tool, 'Cannot execute tool: tool=%s, err=%s', opts.tool, err.message ));
				});
			});
		});
}

function unzipFile( workDir, fileName ) {
	var opts = {
		tool: 'unzip',
		workDir: workDir,
		getParams: function(tmpDir) {
			return [ fileName, '-d', tmpDir ];
		}
	};
	return spawnTool( opts );
}

function untarFile( workDir, fileName ) {
	var opts = {
		tool: 'tar',
		workDir: workDir,
		getParams: function(tmpDir) {
			return ['xf',fileName,'-C',tmpDir];
		}
	};
	return spawnTool( opts );
}

function forwardEventEmitter(obj,evts) {
	//	Events
	obj.on = function() {
		return evts.on.apply(evts,arguments);
	};

	obj.once = function() {
		return evts.once.apply(evts,arguments);
	};

	obj.emit = function() {
		return evts.emit.apply(evts,arguments);
	};

	obj.removeListener = function() {
		return evts.removeListener.apply(evts,arguments);
	};
}

function warnErr() {
	//	Show log in warning
	log.warn.apply( log, arguments );
	//	Remove category
	var args = Array.prototype.slice.call(arguments, 1);
	//	Create error
    return new Error(util.format.apply(util,args));
}

function WaitCondition( fncTest ) {
	var _events = new EventEmitter();
	_events.setMaxListeners(0);
	var self = this || {};

	self.wait = function( cb ) {
		if (!fncTest()) {
			_events.once('notify',function() {
				self.wait( cb );
			});
		}
		else {
			cb();
		}
	};

	self.waitAsync = function() {
		return new bPromise(function(resolv) {
			self.wait(resolv);
		});
	};

	self.notify = function() {
		_events.emit('notify');
	};

	return self;
}

function BasicWaitCondition() {
	assert(this);
	var self = this;
	var _locked = 0;

	function testCondition() {
		return _locked === 0;
	}
	WaitCondition.call(self,testCondition);

	self.isLocked = function() {
		return testCondition() ? false : true;
	};

	self.lock = function(cb) {
		self.wait(function() {
			assert(_locked === 0);
			self.inc();
			cb();
		});
	};

	self.inc = function() {
		_locked++;
	};

	self.dec = function() {
		if (_locked > 0) {
			_locked--;
			self.notify();
		}
	};

	return self;
}
util.inherits(BasicWaitCondition, WaitCondition);

function addServerDestroy(server) {
	assert(server);
	var _connections = {};

	server.on('connection', function(conn) {
		var key = conn.remoteAddress + ':' + conn.remotePort;
		_connections[key] = conn;
		conn.once('close', function() {
			delete _connections[key];
		});
	});

	server.destroy = function(cb) {
		server.close(cb);
		for (var key in _connections) {
			_connections[key].destroy();
		}
	};
}

function createWebService(WebModule,adapter) {
	var self = {};
	let mod;

	function remote() {
		return adapter.registry().get('remoteapi');
	}

	self.onStart = function(cb) {
		assert(cb,'Invalid callback');
		mod = new WebModule(adapter);
		remote().addModule( mod )
			.then( () => cb( undefined, {} ) );
	};

	self.onStop = function(cb) {
		assert(cb,'Invalid callback');
		remote().rmModule( mod.name )
			.then( () => mod = null )
			.finally( () => cb() );
	};

	return Object.freeze(self);
}

module.exports.setupLog = setupLog;
module.exports.isFile = isFile;
module.exports.isDirectory = isDirectory;
module.exports.isHidden = isHidden;
module.exports.ensureDir = ensureDir;
module.exports.cleanDir = cleanDir;
module.exports.removeTree = removeTree;
module.exports.removeTreeAsync = removeTreeAsync;
module.exports.removeTreeSync = removeTreeSync;
module.exports.emitThen = emitThen;
module.exports.isWebURL = isValidURL;
module.exports.fetchURL = fetchURL;
module.exports.fetchURLAsync = fetchURLAsync;
module.exports.doRequest = doRequest;
module.exports.doRequestAsync = doRequestAsync;
module.exports.findFiles = findFiles;
module.exports.forwardEventEmitter = forwardEventEmitter;
module.exports.warnErr = warnErr;
module.exports.diskSpace = diskSpace;
module.exports.spawnTool = spawnTool;
module.exports.unzipFile = unzipFile;
module.exports.untarFile = untarFile;
module.exports.WaitCondition = WaitCondition;
module.exports.BasicWaitCondition = BasicWaitCondition;
module.exports.addServerDestroy = addServerDestroy;
module.exports.createWebService = createWebService;

