'use strict';

var bPromise = require('bluebird');
var fs = bPromise.promisifyAll( require('fs') );
var xmlbuilder = require("xmlbuilder");
var net = require("net");
var scgi = require("scgi-stream");
var Parser = require('./parser');
var Serialize = require('./serialize');

function Rtorrent(host, port) {
	var self = {};

	function array2hash(array, keys) {
		var i = 0;
		var res = {};
		for (var k in keys) {
			res[keys[k]] = array[i++];
		}
		return res;
	}

	function doublearray2hash(array, keys) {
		for (var i in array)
			array[i] = array2hash(array[i], keys);
		return array;
	}

	function makeSCGIXML( method, params ) {
		var xml = xmlbuilder.create('methodCall');
		xml.ele("methodName", method);
		if (params.length > 0) {
			var xmlParams = xml.ele("params");
			params.forEach(function(param) {
				Serialize(param, xmlParams.ele('param'));
			});
		}
		return xml.end({pretty:false});
	}

	self.methodCall = function(method, params) {
		if (params === undefined) {
			params = [];
		}
		log.silly( 'rtorrent', 'methodCall: method=%s', method );

		return new bPromise(function(resolve,reject) {
			//	Serialize xml
			var xml;
			try {
				xml = makeSCGIXML(method, params);
			} catch(err) {
				log.warn('rtorrent', 'Cannot serialize xml message: err=%s', err.message );
				reject( err );
			}

			var options = {
				stream: net.connect( port, host ),
				path: "/"
			};
			var req = scgi.request(options);
			req.on("response", function(res) {
				var parser = new Parser();
				parser.deserialize(res,function(err,data) {
					if (err) {
						reject(err);
					}
					else {
						resolve(data);
					}
				});
			});
			options.stream.on( "error", reject );
			req.on( "error", reject );
			req.end(xml);
		});
	};

	self.getMulticall = function(method, param, cmds) {
		var cmdarray = param;

		for (var c in cmds)
			cmdarray.push(cmds[c]+'=');

		return self.methodCall(method, cmdarray)
			.then(function(data) {
				return doublearray2hash(data, Object.keys(cmds));
			});
	};

	self.systemMulticall = function(cmds) {
		var array = [];

		for (var c in cmds)
			array.push({
				'methodName': cmds[c],
				'params': [],
			});

		return self.methodCall( 'system.multicall', [array] )
			.then(function(data) {
				var i = 0;
				var res = {};
				for (var k in cmds) {
					res[k] = data[i++][0];
				}
				return res;
			});
	};

	//	RPC generic
	self.listMethods = function() {
		return self.methodCall( 'system.listMethods' );
	};

	self.methodSignature = function( method ) {
		return self.methodCall( 'system.methodSignature', [method] );
	};

	self.methodHelp = function(method) {
		return self.methodCall( 'system.methodHelp', [method] );
	};

	//	Rtorrent global
	self.getGlobals = function() {
		return self.systemMulticall( fields.global );
	};

	self.shutdown = function() {
	};

	//	Rtorrent specific
	self.getAll = function() {
		return self.getMulticall('d.multicall', ['main'], fields.torrents);
    };

	self.get = function(hash) {
		return self.getAll().then(function(all) {
			return all.find( (item) => item.hash === hash );
		});
    };

	self.start = function(link) {
		return self.methodCall('load_start', [link]);
	};

	self.stop = function(hash,needRemove) {
		return self.methodCall('d.stop', [hash] )
			.then( () => self.get('d.close', [hash]) )
			.then( function() {
				if (needRemove) {
					return self.methodCall('d.erase', [hash] );
				}
				return bPromise.resolve();
			});
	};

	self.getTrackers = function(hash) {
		return self.getMulticall('t.multicall', [hash, ''], fields.trackers );
	};

	self.getFiles = function(hash) {
		return this.getMulticall('f.multicall', [hash, ''], fields.files);
	};

	self.getPeers = function(hash) {
		return this.getMulticall('p.multicall', [hash, ''], fields.peers);
	};

	return self;
}

module.exports = Rtorrent;

var fields = {
    global: {
		up_rate: 'get_up_rate',
        down_rate: 'get_down_rate',
        up_total: 'get_up_total',
        down_total: 'get_down_total',
        bind: 'get_bind',
        check_hash: 'get_check_hash',
        dht_port: 'get_dht_port',
        directory: 'get_directory',
        download_rate: 'get_download_rate',
        http_cacert: 'get_http_cacert',
        http_capath: 'get_http_capath',
        http_proxy: 'get_http_proxy',
        ip: 'get_ip',
        max_downloads_div: 'get_max_downloads_div',
        max_downloads_global: 'get_max_downloads_global',
        max_file_size: 'get_max_file_size',
        max_memory_usage: 'get_max_memory_usage',
        max_open_files: 'get_max_open_files',
        max_open_http: 'get_max_open_http',
        max_peers: 'get_max_peers',
        max_peers_seed: 'get_max_peers_seed',
        max_uploads: 'get_max_uploads',
        max_uploads_global: 'get_max_uploads_global',
        min_peers_seed: 'get_min_peers_seed',
        min_peers: 'get_min_peers',
        peer_exchange: 'get_peer_exchange',
        port_open: 'get_port_open',
        upload_rate: 'get_upload_rate',
        port_random: 'get_port_random',
        port_range: 'get_port_range',
        preload_min_size: 'get_preload_min_size',
        preload_required_rate: 'get_preload_required_rate',
        preload_type: 'get_preload_type',
        proxy_address: 'get_proxy_address',
        receive_buffer_size: 'get_receive_buffer_size',
        safe_sync: 'get_safe_sync',
        scgi_dont_route: 'get_scgi_dont_route',
        send_buffer_size: 'get_send_buffer_size',
        session: 'get_session',
        session_lock: 'get_session_lock',
        session_on_completion: 'get_session_on_completion',
        split_file_size: 'get_split_file_size',
        split_suffix: 'get_split_suffix',
        timeout_safe_sync: 'get_timeout_safe_sync',
        timeout_sync: 'get_timeout_sync',
        tracker_numwant: 'get_tracker_numwant',
        use_udp_trackers: 'get_use_udp_trackers',
        max_uploads_div: 'get_max_uploads_div',
        max_open_sockets: 'get_max_open_sockets'
    },
    peers: {
        address: 'p.get_address',
        client_version: 'p.get_client_version',
        completed_percent: 'p.get_completed_percent',
        down_rate: 'p.get_down_rate',
        down_total: 'p.get_down_total',
        id: 'p.get_id',
        port: 'p.get_port',
        up_rate: 'p.get_up_rate',
        up_total: 'p.get_up_total'
    },
    files: {
        range_first: 'f.get_range_first',
        range_second: 'f.get_range_second',
        size: 'f.get_size_bytes',
        chunks: 'f.get_size_chunks',
        completed_chunks: 'f.get_completed_chunks',
        fullpath: 'f.get_frozen_path',
        path: 'f.get_path',
        priority: 'f.get_priority',
        is_created: 'f.is_created=',
        is_open: 'f.is_open=',
        last_touched: 'f.get_last_touched=',
        match_depth_next: 'f.get_match_depth_next=',
        match_depth_prev: 'f.get_match_depth_prev=',
        offset: 'f.get_offset=',
        path_components: 'f.get_path_components=',
        path_depth: 'f.get_path_depth=',
    },
    trackers: {
        id: 't.get_id',
        group: 't.get_group',
        type: 't.get_type',
        url: 't.get_url',
        enabled: 't.is_enabled',
        open: 't.is_open',
        min_interval: 't.get_min_interval',
        normal_interval: 't.get_normal_interval',
        scrape_complete: 't.get_scrape_complete',
        scrape_downloaded: 't.get_scrape_downloaded',
        scrape_incomplete: 't.get_scrape_incomplete',
        scrape_time_last: 't.get_scrape_time_last',
    },
    torrents: {
        hash: 'd.get_hash',
        torrent: 'd.get_tied_to_file',
        torrentsession: 'd.get_loaded_file',
        path: 'd.get_base_path',
        name: 'd.get_base_filename',
        size: 'd.get_size_bytes',
        skip: 'd.get_skip_total',
        completed: 'd.get_completed_bytes',
        down_rate: 'd.get_down_rate',
        down_total: 'd.get_down_total',
        up_rate: 'd.get_up_rate',
        up_total: 'd.get_up_total',
        message: 'd.get_message',
        bitfield: 'd.get_bitfield',
        chunk_size: 'd.get_chunk_size',
        chunk_completed: 'd.get_completed_chunks',
        createdAt: 'd.creation_date',
        active: 'd.is_active',
        open: 'd.is_open',
        complete: 'd.get_complete',
        hashing: 'd.is_hash_checking',
        hashed: 'd.is_hash_checked',
        leechers: 'd.get_peers_accounted',
        seeders: 'd.get_peers_complete',
        free_disk_space: 'd.free_diskspace',
    },
};

