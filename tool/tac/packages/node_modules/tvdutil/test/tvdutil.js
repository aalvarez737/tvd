'use strict';

var mockfs = require('mock-fs');
var chai = require("chai");
chai.config.includeStack = true;
var assert = chai.assert;
var nock = require('nock');
var tvdutil = require('..');
var url = require('url');
var EventEmitter = require('events').EventEmitter;
var ChildProc = require('child_process');
var fs = require('fs');
var _ = require('lodash');
var bPromise = require('bluebird');

function createServer(url, statusCode, type) {
	if (!type) {
		type = 'application/json';
	}
	return nock(url)
		.defaultReplyHeaders({
			'Content-Type': type
		})
		.post('/', '')
		.reply(statusCode, "[\"pepe\"]")
		.post('/')
		.reply(statusCode, function(url, data) {
			if (data.invalid) {
				return "pepe";
			}
			else {
				return data;
			}
		});
}

describe('tvdutil', function() {
	describe('setupLog', function() {
		beforeEach(function() {
			mockfs({});
		});

		afterEach(function() {
			mockfs.restore();
			delete global.log
			assert.equal( global.log );
		});

		it('should register in global scope', function() {
			assert.equal( global.log );
			tvdutil.setupLog( 'info' );
			assert( global.log );
			assert( log );
			assert.equal( log.level, 'info' );
		});

		it('should change level', function() {
			assert.equal( global.log );
			tvdutil.setupLog( 'silly' );
			assert( log );
			assert.equal( log.level, 'silly' );
		});

		it('should load configuration if exists', function() {
			assert.equal( global.log );
			fs.writeFileSync( 'log.cfg', '{ "pepe": "silly" }' );
			tvdutil.setupLog( 'silly', 'log.cfg' );
			assert( log );
			assert.equal( log.level, 'silly' );
		});

		it('should validate log configuration if exists', function() {
			assert.equal( global.log );
			fs.writeFileSync( 'log.cfg', '{ "pepe: "silly" }' );
			tvdutil.setupLog( 'silly', 'log.cfg' );
			assert( log );
		});

		it('should handle log configuration not exists', function() {
			assert.equal( global.log );
			tvdutil.setupLog( 'silly', 'log1.cfg' );
			assert( log );
		});

		it('should setup individual log levels for categories', function(done) {
			assert.equal( global.log );
			fs.writeFileSync( 'log.cfg', '{ "Test": "verbose" }' );
			tvdutil.setupLog( 'info', 'log.cfg' );
			assert( log );
			var count = 0;
			var origCursorWrite = log.cursor.write.bind(log.cursor);

			log.cursor.write = function(msg) {
				if (msg.startsWith('\u001b')) {
					return origCursorWrite(msg);
				}
				switch (msg) {
					case 'info':
					case 'verb':
					case 'sill':
					case 'Test':
					case '':
					case ' ':
						return origCursorWrite(msg);
				}

				count++;
				switch (count) {
					case 1: assert.equal(msg, ' log_info\n'); return origCursorWrite(msg);
					case 2: assert.equal(msg, ' log_verbose\n'); return origCursorWrite(msg);
					default: assert(false);
				}
			};

			log.info('Test', 'log_info');
			log.verbose('Test', 'log_verbose');
			log.silly('Test', 'log_silly');

			process.nextTick(()=>{
				log.cursor.write = origCursorWrite;
				assert.equal(2, count);
				done();
			});
		});
	});

	describe('isFile', function() {
		var testFS = Object.freeze({
			'manifest.json': 'agun dato',
			'/empty/': {},
			'/no_empty/' : {
				'readme.txt': 'algun dato',
				'second': {}
			}
		});

		beforeEach(function() {
			mockfs(testFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should validate file', function() {
			assert.isTrue( tvdutil.isFile( 'manifest.json' ) );
		});

		it('should validate inexistent file', function() {
			assert.isFalse( tvdutil.isFile( 'readme.json' ) );
		});

		it('should fail validate directory', function() {
			assert.isFalse( tvdutil.isFile( '/empty' ) );
		});
	});

	describe('isHidden', function() {
		it('Should check for hidden files', function() {
			assert.isTrue( tvdutil.isHidden( '.file1.json' ) );
			assert.isFalse( tvdutil.isHidden( 'file1.json' ) );
		});
	});

	describe('findFiles', function() {
		var testFS = Object.freeze({
			'/test_dir/' : {
				'empty': {},
				'readme.txt': 'algun dato',
				'second': {
					'readme2.txt': 'algun dato',
					'second_empty': {},
					'third': {
						'readme3.txt': 'algun dato',
					}
				}
			}
		});

		beforeEach(function() {
			mockfs(testFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		function findFile( entries, info ) {
			if (info.stats.isFile()) {
				entries.push( info );
			}
			return bPromise.resolve();
		}

		it('should find recursive all files', function(done) {
			let entries = [];
			tvdutil.findFiles({
				root: '/test_dir',
				cbEntry: _.partial(findFile,entries),
				cbEnd: () => entries
			}).then(function(result) {
				assert.equal( result.length, 3 );
				assert.deepEqual( result, entries );
				done();
			});
		});

		it('should find only on 2 levels', function(done) {
			let entries = [];
			tvdutil.findFiles({
				root: '/test_dir',
				level: 1,
				cbEntry: _.partial(findFile,entries),
				cbEnd: () => entries
			}).then(function(result) {
				assert.equal( result.length, 2 );
				assert.deepEqual( result[0].absPath, '/test_dir/readme.txt' );
				assert.deepEqual( result[1].absPath, '/test_dir/second/readme2.txt' );
				done();
			});
		});
	});

	describe('ensureDir', function() {
		var dirFS = Object.freeze({'/tmp': {}});

		beforeEach(function() {
			mockfs(dirFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should create dir if not exists', function() {
			var dir = '/tmp/test_directory';
			assert( !tvdutil.isDirectory(dir) );
			tvdutil.ensureDir(dir);
			assert( tvdutil.isDirectory(dir) );
		});

		it('should succeed if dir already exist', function() {
			var dir = '/tmp/test_directory';
			fs.mkdirSync(dir);
			assert( tvdutil.isDirectory(dir) );
			tvdutil.ensureDir(dir);
			assert( tvdutil.isDirectory(dir) );
		});
	});

	describe('isDirectory', function() {
		var dirFS = Object.freeze({
			'/empty/': {},
			'/no_empty/' : {
				'readme.txt': 'algun dato',
				'second': {}
			}
		});

		beforeEach(function() {
			mockfs(dirFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should validate dir', function() {
			assert.isTrue( tvdutil.isDirectory( '/empty' ) );
		});

		it('should validate inexistent dir', function() {
			assert.isFalse( tvdutil.isDirectory( '/no_existe' ) );
		});

		it('should fail validate file', function() {
			assert.isFalse( tvdutil.isDirectory( '/no_empty/readme.txt' ) );
		});
	});

	describe('forwardEventEmitter', function() {
		it('should forward EventEmitter methods to object', function() {
			var fakeEmitter = {
				on: function() { return 'on_called'; },
				once: function() { return 'once_called'; },
				emit: function() { return 'emit_called'; },
				removeListener: function() { return 'removeListener_called'; }
			};
			var obj = {};
			tvdutil.forwardEventEmitter(obj, fakeEmitter);
			assert( _.isFunction(obj.on) );
			assert( _.isFunction(obj.once) );
			assert( _.isFunction(obj.emit) );
			assert( _.isFunction(obj.removeListener) );
			assert.equal( obj.on(), 'on_called' )
			assert.equal( obj.once(), 'once_called' )
			assert.equal( obj.emit(), 'emit_called' )
			assert.equal( obj.removeListener(), 'removeListener_called' )
		});
	});

	describe('spawnTool', function() {
		var oldSpawn;
		var exitCode;
		var onError;
		beforeEach(function() {
			exitCode = 0;
			oldSpawn = ChildProc.spawn;
			ChildProc.spawn = function() {
				var self = {};
				self.on = function(s,cb) {
					if (s === 'close') {
						if (!onError) {
							setTimeout( function() {
								cb( exitCode )
							}, 10 );
						}
					}
					else if (s === 'error') {
						if (onError) {
							setTimeout(function() {
								cb( onError() );
							}, 10 );
						}
					}
				};
				return self;
			};
			mockfs( {'/tmp': {} } );
		});

		afterEach(function() {
			mockfs.restore();
			ChildProc.spawn = oldSpawn;
		});

		function getFiles(dir) {
			return fs.readdirSync(dir);
		}

		it('should spawn and check return code', function(done) {
			var tmp = null;
			var opts = {
				tool: 'unzip',
				workDir: '/tmp',
				getParams: function(tmpDir) {
					tmp = tmpDir;
					return [ 'test.zip', '-d', tmpDir ];
				}
			};
			tvdutil.spawnTool( opts )
				.then(function(outDir) {
					assert(tmp);
					assert.equal( outDir, tmp );
					assert.isTrue( tvdutil.isDirectory(outDir) );
					assert.equal( getFiles(tmp), 0 );
					done();
				});
		});

		it('should unzipFile ok', function(done) {
			tvdutil.unzipFile( '/tmp', 'pepe.zip' )
				.then(function(outDir) {
					assert.isTrue( tvdutil.isDirectory(outDir) );
					assert.equal( getFiles(outDir), 0 );
					done();
				});
		});

		it('should untarFile ok', function(done) {
			tvdutil.untarFile( '/tmp', 'pepe.tar' )
				.then(function(outDir) {
					assert.isTrue( tvdutil.isDirectory(outDir) );
					assert.equal( getFiles(outDir), 0 );
					done();
				});
		});

		it('should clean temporary directory if error', function(done) {
			//	Return 1
			exitCode = 1;

			var tmp = null;
			var opts = {
				tool: 'unzip',
				workDir: '/tmp',
				getParams: function(tmpDir) {
					tmp = tmpDir;
					return [ 'test.zip', '-d', tmpDir ];
				}
			};
			tvdutil.spawnTool( opts )
				.catch(function(err) {
					assert(err);
					assert.isTrue( err.message.indexOf('Error processing tool') >= 0 );
					assert.isFalse( tvdutil.isDirectory(tmp) );
					done();
				});
		});

		it('should fail if cannot create temporary directory', function(done) {
			var tmp = null;
			var opts = {
				tool: 'unzip',
				workDir: '/tmp/pepe',
				getParams: function(tmpDir) {
					tmp = tmpDir;
					return [ 'test.zip', '-d', tmpDir ];
				}
			};
			tvdutil.spawnTool( opts )
				.catch(function(err) {
					assert(err);
					assert.isTrue( err.message.indexOf('no such file or directory') >= 0 );
					assert.isNull(tmp);
					done();
				});
		});

		it('should fail if by error handler', function(done) {
			onError = function() {
				return new Error('pepe');
			};
			var tmp = null;
			var opts = {
				tool: 'unzip',
				workDir: '/tmp',
				getParams: function(tmpDir) {
					tmp = tmpDir;
					return [ 'test.zip', '-d', tmpDir ];
				}
			};
			tvdutil.spawnTool( opts )
				.catch(function(err) {
					assert(err);
					assert.equal( err.message, 'Cannot execute tool: tool=unzip, err=pepe');
					assert(tmp);
					assert.isFalse( tvdutil.isDirectory(tmp) );
					done();
				});
		});
	});

	describe('isValidURL', function() {
		it('should validate url', function() {
			var oURL = url.parse( 'http://www.pepe.com' );
			assert.isTrue( tvdutil.isWebURL( oURL ) );
		});

		it('should validate https url', function() {
			var oURL = url.parse( 'https://www.pepe.com' );
			assert.isTrue( tvdutil.isWebURL( oURL ) );
		});

		it('should fail validating url', function() {
			var oURL = url.parse( 'htt://www.pepe.com' );
			assert.isFalse( tvdutil.isWebURL( oURL ) );
		});

		it('should fail validating empty protocol url', function() {
			var oURL = url.parse( 'www.pepe.com' );
			assert.isFalse( tvdutil.isWebURL( oURL ) );
		});
	});

	describe('removeTreeSync', function() {
		var removeTreeFS = Object.freeze({
			'/empty/': {},
			'/no_empty/' : {
				'readme.txt': 'algun dato',
				'second': {}
			}
		});

		beforeEach(function() {
			mockfs(removeTreeFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should remove empty directory', function() {
			tvdutil.removeTreeSync( '/empty' );
			assert.isFalse( fs.existsSync('/empty') );
		});

		it('should remove non empty directory', function() {
			tvdutil.removeTreeSync( '/no_empty' );
			assert.isFalse( fs.existsSync('/no_empty') );
		});

		it('should not remove invalid directory', function() {
			try {
				tvdutil.removeTreeSync( '/invalid' );
			} catch(err) {
				assert.isDefined( err );
				assert.strictEqual( err.message, 'ENOENT, no such file or directory \'/invalid\'' );
				assert.isTrue( fs.existsSync('/empty') );
				assert.isTrue( fs.existsSync('/no_empty') );
			};
		});

		it('should remove file if parameter is file', function() {
			tvdutil.removeTreeSync( '/no_empty/readme.txt' );
			assert.isFalse( fs.existsSync('/no_empty/readme.txt') );
			assert.isTrue( fs.existsSync('/no_empty') );
		});
	});

	describe('removeTree', function() {
		var removeTreeFS = Object.freeze({
			'/empty/': {},
			'/no_empty/' : {
				'readme.txt': 'algun dato',
				'second': {}
			}
		});

		beforeEach(function() {
			mockfs(removeTreeFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should remove empty directory', function(done) {
			tvdutil.removeTree( '/empty', function(err) {
				assert.isUndefined( err );
				assert.isFalse( fs.existsSync('/empty') );
				done();
			});
		});

		it('should remove non empty directory', function(done) {
			tvdutil.removeTree( '/no_empty', function(err) {
				assert.isUndefined( err );
				assert.isFalse( fs.existsSync('/no_empty') );
				done();
			});
		});

		it('should not remove invalid directory', function(done) {
			tvdutil.removeTree( '/invalid', function(err) {
				assert.isDefined( err );
				assert.strictEqual( err.message, 'ENOENT, no such file or directory \'/invalid\'' );
				assert.isTrue( fs.existsSync('/empty') );
				assert.isTrue( fs.existsSync('/no_empty') );
				done();
			});
		});

		it('should remove file if parameter is file', function(done) {
			tvdutil.removeTree( '/no_empty/readme.txt', function(err) {
				assert.isUndefined( err );
				assert.isFalse( fs.existsSync('/no_empty/readme.txt') );
				assert.isTrue( fs.existsSync('/no_empty') );
				done();
			});
		});
	});

	describe('cleanDir', function() {
		var removeTreeFS = Object.freeze({
			'/empty/': {},
			'/no_empty/' : {
				'readme.txt': 'algun dato',
				'second': {}
			}
		});

		beforeEach(function() {
			mockfs(removeTreeFS);
		});

		afterEach(function() {
			mockfs.restore();
		});

		it('should remove empty directory', function() {
			var dir = '/empty';
			tvdutil.cleanDir( dir );
			assert.isTrue( fs.existsSync( dir ) );
			var files = fs.readdirSync( dir );
			assert.equal( files.length, 0 );
		});

		it('should remove non empty directory', function() {
			var dir = '/no_empty';
			tvdutil.cleanDir( dir );
			assert.isTrue( fs.existsSync( dir ) );
			var files = fs.readdirSync( dir );
			assert.equal( files.length, 0 );
		});

		it('should create if not exists', function() {
			var dir = '/not_exists';
			tvdutil.cleanDir( dir );
			assert.isTrue( fs.existsSync( dir ) );
			var files = fs.readdirSync( dir );
			assert.equal( files.length, 0 );
		});

		it('should remove file if parameter is file', function() {
			var dir = '/no_empty/readme.txt';
			tvdutil.cleanDir( dir );
			assert.isTrue( fs.existsSync( dir ) );
			var files = fs.readdirSync( dir );
			assert.equal( files.length, 0 );
		});
	});

	describe('emitThen', function() {
		var evt = null;

		beforeEach(function() {
			evt = new EventEmitter();
		});

		afterEach(function() {
			evt = null;
		});

		it('should dispatch one single event', function(done) {
			var signalPepeCalled=0;
			evt.on('signalPepe',function(data) {
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
			});
			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 1 );
				done();
			});
		});

		it('should dispatch many event', function(done) {
			var signalPepeCalled=0;
			var signalPepeHandler1=0;
			var signalPepeHandler2=0;

			evt.on('signalPepe',function(data) {
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalPepeHandler1++;
			});

			evt.on('signalPepe',function(data) {
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalPepeHandler2++;
			});

			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 2 );
				assert.isTrue( signalPepeHandler1 === 1 );
				assert.isTrue( signalPepeHandler2 === 1 );
				done();
			});
		});

		it('should dispatch single async event', function(done) {
			var signalPepeCalled=0;
			var evtHandler = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				cb();
			}
			evtHandler.isAsync = true;

			evt.on('signalPepe', evtHandler );

			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 1 );
				done();
			});
		});

		it('should dispatch single async event with timer', function(done) {
			var signalPepeCalled=0;
			var evtHandler = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				setTimeout(function() {
					cb();
				},10);
			}
			evtHandler.isAsync = true;

			evt.on('signalPepe', evtHandler );

			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 1 );
				done();
			});
		});

		it('should dispatch multiple async events', function(done) {
			var signalPepeCalled=0;
			var signalHandler1=0;
			var signalHandler2=0;
			var evtHandler1 = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler1++;
				setTimeout(function() {
					cb();
				},10);
			}
			evtHandler1.isAsync = true;

			var evtHandler2 = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler2++;
				setTimeout(function() {
					cb();
				},10);
			}
			evtHandler2.isAsync = true;

			evt.on('signalPepe', evtHandler1 );
			evt.on('signalPepe', evtHandler2 );

			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 2 );
				assert.isTrue( signalHandler1 === 1 );
				assert.isTrue( signalHandler2 === 1 );
				done();
			});
		});

		it('should dispatch multiple async/sync events', function(done) {
			var signalPepeCalled=0;
			var signalHandler1=0;
			var signalHandler2=0;
			var signalHandler3=0;
			var signalHandler4=0;
			var evtHandler1 = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler1++;
				setTimeout(function() {
					cb();
				},10);
			}
			evtHandler1.isAsync = true;

			var evtHandler2 = function(data,cb) {
				assert.isTrue( cb !== undefined );
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler2++;
				setTimeout(function() {
					cb();
				},10);
			}
			evtHandler2.isAsync = true;

			evt.on('signalPepe', evtHandler1 );
			evt.on('signalPepe',function(data) {
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler3++;
			});
			evt.on('signalPepe', evtHandler2 );
			evt.on('signalPepe',function(data) {
				assert.isTrue( data === 'pepe' );
				signalPepeCalled++;
				signalHandler4++;
			});

			tvdutil.emitThen( evt, 'signalPepe', 'pepe' ).then(function() {
				assert.isTrue( signalPepeCalled === 4 );
				assert.isTrue( signalHandler1 === 1 );
				assert.isTrue( signalHandler2 === 1 );
				assert.isTrue( signalHandler3 === 1 );
				assert.isTrue( signalHandler4 === 1 );
				done();
			});
		});
	});

	describe('WaitCondition', function() {
		it('shoud wait for a basic condition', function(done) {
			var test = 0;
			var fncTest = function() {
				return test > 0 ? true : false;
			};
			var cWait = new tvdutil.WaitCondition( fncTest );
			cWait.wait( function() {
				done();
			});
			test++;
			cWait.notify();
		});

		it('shoud wait for a basic condition (async)', function(done) {
			var test = 0;
			var fncTest = function() {
				return test > 0 ? true : false;
			};
			var cWait = new tvdutil.WaitCondition( fncTest );
			cWait.waitAsync()
			.then( done );
			test++;
			cWait.notify();
		});

		it('shoud not wait if test ok', function(done) {
			var fncTest = function() { return true; };
			var cWait = new tvdutil.WaitCondition( fncTest );
			cWait.wait( function() {
				done();
			});
		});

		it('shoud wait for unlimited waiters', function() {
			var test = 1;
			var fncTest = function() { return test === 0; };
			var cWait = new tvdutil.WaitCondition( fncTest );
			for (var i=0; i<50; i++) {
				cWait.wait(function() {
					//	Do nothin
				});
			}
			for (var j=0; j<50; j++) {
				test=0;
				cWait.notify();
			}
		});

		it('shoud wait multiple times', function(done) {
			var test = 1;

			var fncTest = function() {
				if (test === 0) {
					return true;
				}
				return false;
			};

			var fncWork = function(id) {
				//	Lock others
				assert.isTrue( test === 0 );
				test = 1;

				//	Do work

				//	Unlock others
				if (id == 9) {
					done();
				}
				else {
					test=0
					cWait.notify();
				}
			}

			var cWait = new tvdutil.WaitCondition( fncTest );
			for (var i=0; i<10; i++) {
				cWait.wait(fncWork.bind(null,i));
			}

			test = 0;
			cWait.notify();
		});
	});

	describe('BasicWaitCondition', function() {
		it('shoud wait for a basic condition', function(done) {
			var cWait = new tvdutil.BasicWaitCondition();
			cWait.inc();
			assert( cWait.isLocked() );
			cWait.wait( function() {
				done();
			});
			cWait.dec();
			cWait.dec();
			assert( !cWait.isLocked() );
		});

		it('shoud wait and lock a basic condition', function(done) {
			var cWait = new tvdutil.BasicWaitCondition();
			cWait.inc();
			assert( cWait.isLocked() );
			cWait.lock(function() {
				assert( cWait.isLocked() );
				done();
			});
			cWait.dec();
		});
	});

	describe('fetchURL', function() {
		it('shoud fetch readme.txt from tvdgit', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt'
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			})
		});

		it('shoud fetch readme.txt from tvdgit showing progress bar', function(done) {
			var last_progress = 0;
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'progress': function(progress) {
					assert.isTrue( progress >= last_progress );
					last_progress = progress;
				},
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isTrue( last_progress === 100 );
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			})
		});

		it('shoud fetch readme.txt from tvdgit and check md5', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'md5': 'e20a39888abb761b5785459998bc6384'
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			});
		});

		it('shoud fetch readme.txt from tvdgit and check with invalid md5', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'md5': 'e20a39888abb761b5785459998bc6385'
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isDefined( err );
				assert.isTrue( err.message === 'Signature error' );
				assert.isFalse( tvdutil.isFile( options.fileOutput ) );
				done();
			});
		});

		it('shoud fetch readme.txt from tvdgit and check size', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'size': 57
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			});
		});

		it('shoud fetch readme.txt from tvdgit and check with invalid size', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'size': 570
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isDefined( err );
				assert.isTrue( err.message === 'Downloaded file differ in size' );
				assert.isFalse( tvdutil.isFile( options.fileOutput ) );
				done();
			});
		});

		it('shoud fetch readme.txt from tvdgit and check for enought space', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/tmp/readme.txt',
				'size': 570,
				'grantFreeDiskSpace': 1024*1024*1024*1024*1024
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isDefined( err );
				assert.isTrue( err.message.indexOf('Not enough free disk space') !== -1 );
				assert.isFalse( tvdutil.isFile( options.fileOutput ) );
				done();
			});
		});

		it('shoud fetch readme.txt from tvdgit and check invalid output', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme.txt',
				'fileOutput': '/pepe/readme.txt',
				'size': 570
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isDefined( err );
				assert.isTrue( err.message.indexOf('Command failed') !== -1 );
				assert.isFalse( tvdutil.isFile( options.fileOutput ) );
				done();
			});
		});

		it('shoud not fetch invalid file from tvdgit', function(done) {
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/readme_invalid.txt',
				'fileOutput': '/tmp/readme_invalid.txt'
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isDefined( err );
				assert.isTrue( err.message === ('Cannot fetch URL: url=' + options.url) );
				assert.isFalse( tvdutil.isFile( options.fileOutput ) );
				done();
			})
		});

		xit('shoud fetch testlink_1.8.4.tgz from tvdgit and check md5 showing progress bar', function(done) {
			this.timeout(5000);
			var last_progress = 0;
			var options = {
				'url': 'http://172.16.0.206/testlink_1.8.4.tgz',
				'fileOutput': '/tmp/testlink_1.8.4.tgz',
				'md5': '8abe30dda66e6c1d2d6c1fb532117b19',
				'progress': function(progress) {
					assert.isTrue( progress >= last_progress );
					last_progress = progress;
				},
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isTrue( last_progress === 100 );
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			});
		});

		it('should fetch image-201501050344-2871.tac from tvdgit', function(done) {
			this.timeout(20000);
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/image-201501050344-2871.tac',
				'fileOutput': '/tmp/image-201501050344-2871.tac',
				'md5': '18be1a5fc24c57cf967e2a73bb1b42eb',
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			});
		});

		it('should fetch image-201501050344-2871.tac from tvdgit validating progress', function(done) {
			this.timeout(20000);
			var last_progress = 0;
			var options = {
				'url': 'http://172.16.0.206/tac_testcases/image-201501050344-2871.tac',
				'fileOutput': '/tmp/image-201501050344-2871.tac',
				'md5': '18be1a5fc24c57cf967e2a73bb1b42eb',
				'progress': function(progress) {
					assert.isTrue( progress >= last_progress );
					last_progress = progress;
				},
			};
			tvdutil.fetchURL( options, function(err) {
				assert.isTrue( last_progress === 100 );
				assert.isUndefined( err );
				assert.isTrue( tvdutil.isFile( options.fileOutput ) );
				fs.unlink( options.fileOutput );
				done();
			});
		});

		describe('authenticatedFetchURL', function() {
			var username='buildbot';
			var password='0303456';
			var url='http://172.16.0.206/buildbot/builds/logos/logos_4.xml';
			var fileOutput='/tmp/logos_4.xml';
			var size=271;
			it('should fetch using authentication logos_4.xml from tvdgit', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isUndefined( err );
					assert.isTrue( tvdutil.isFile( options.fileOutput ) );
					fs.unlink( options.fileOutput );
					done();
				})
			});

			it('should fetch using authentication logos_4.xml from tvdgit showing progress bar', function(done) {
				var last_progress = 0;
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'progress': function(progress) {
						assert.isTrue( progress >= last_progress );
						last_progress = progress;
					},
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isTrue( last_progress === 100 );
					assert.isUndefined( err );
					assert.isTrue( tvdutil.isFile( options.fileOutput ) );
					fs.unlink( options.fileOutput );
					done();
				})
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check md5', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'md5': '0a89d9dd961cc79ebd3c690d42dcb06e'
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isUndefined( err );
					assert.isTrue( tvdutil.isFile( options.fileOutput ) );
					fs.unlink( options.fileOutput );
					done();
				});
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check with invalid md5', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'md5': 'e20a39888abb761b5785459998bc6385'
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isDefined( err );
					assert.isTrue( err.message === 'Signature error' );
					assert.isFalse( tvdutil.isFile( options.fileOutput ) );
					done();
				});
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check size', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'size': size
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isUndefined( err );
					assert.isTrue( tvdutil.isFile( options.fileOutput ) );
					fs.unlink( options.fileOutput );
					done();
				});
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check with invalid size', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'size': size+10
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isDefined( err );
					assert.isTrue( err.message === 'Downloaded file differ in size' );
					assert.isFalse( tvdutil.isFile( options.fileOutput ) );
					done();
				});
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check for enought space', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': fileOutput,
					'size': size+10,
					'grantFreeDiskSpace': 1024*1024*1024*1024*1024
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isDefined( err );
					assert.isTrue( err.message.indexOf('Not enough free disk space') !== -1 );
					assert.isFalse( tvdutil.isFile( options.fileOutput ) );
					done();
				});
			});

			it('should fetch using authentication logos_4.xml from tvdgit and check invalid output', function(done) {
				var options = {
					'url': url,
					'user': username,
					'password': password,
					'fileOutput': '/pepe/logos_4.xml',
					'size': size + 10
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isDefined( err );
					assert.isTrue( err.message.indexOf('Command failed') !== -1 );
					assert.isFalse( tvdutil.isFile( options.fileOutput ) );
					done();
				});
			});

			it('should not fetch invalid file from tvdgit', function(done) {
				var options = {
					'url': 'http://172.16.0.206/tac_testcases/readme_invalid.txt',
					'fileOutput': '/tmp/readme_invalid.txt',
					'user': username,
					'password': password,
				};
				tvdutil.fetchURL( options, function(err) {
					assert.isDefined( err );
					assert.isTrue( err.message === ('Cannot fetch URL: url=' + options.url) );
					assert.isFalse( tvdutil.isFile( options.fileOutput ) );
					done();
				})
			});
		});
	});

	describe('diskSpace', function() {
		it('should return disk space information', function(done) {
			tvdutil.diskSpace( '/tmp', function(err,stats) {
				assert.isUndefined(err);
				assert.isTrue( stats.total > 0 );
				assert.isTrue( stats.free > 0 );
				done();
			});
		});

		it('should fail when path is invalid', function(done) {
			tvdutil.diskSpace( '/pepe_no_existe', function(err) {
				assert.isDefined(err);
				assert.include( err.message, 'Command failed: df -k \'/pepe_no_existe\'\ndf: /pepe_no_existe: No such file or directory\n' );
				done();
			});
		});
	});

	describe('warnErr', function() {
		it( 'should print log in warning and create error', function() {
			var old = global.log;
			global.log = {
				warn: function( cat, p1, p2 ) {
					assert.equal( cat, 'cat' );
					assert.equal( p1, 'Esto debe funcionar: param=%s' );
					assert.equal( p2, 'pepe' );
				}
			}
			var err = tvdutil.warnErr( 'cat', 'Esto debe funcionar: param=%s', 'pepe' );
			assert.equal( err.message, 'Esto debe funcionar: param=pepe' );
			global.log = old;
		});
	});

	describe('addServerDestroy', function() {
		function createConnection() {
			var self = {};
			var signals = {};
			self.remoteAddress = 'pepe';
			self.remotePort = 80;
			self.once = function(sig,cb) {
				signals[sig] = cb;
			};
			self.destroy = function() {
			};
			self.sendClose = function() {
				signals['close']();
			};
			return self;
		}

		function createServer() {
			var self = {};
			var signals = {};

			self.closeCB = null;
			self.addConnection = function(conn) {
				signals['connection'](conn);
			};

			self.close = function(cb) {
				self.closeCB = cb;
			};
			self.on = function(sig,cb) {
				signals[sig] = cb;
			};
			return self;
		}

		it( 'should add server method and call to stop', function(done) {
			var server = createServer();
			tvdutil.addServerDestroy( server );
			assert(server.destroy);
			server.destroy(done);
			server.closeCB();
		});

		it( 'should add connection and when close, call destroy', function(done) {
			var server = createServer();
			tvdutil.addServerDestroy( server );

			var destroyCalled = 0;
			var conn = createConnection();
			conn.destroy = function() {
				destroyCalled++;
			};
			server.addConnection( conn );

			server.destroy(function() {
				setTimeout(function() {
					assert.equal( destroyCalled, 1 );
					done();
				}, 100 );
			});
			server.closeCB();
		});

		it( 'should add connection and call close before destroy server', function(done) {
			var server = createServer();
			tvdutil.addServerDestroy( server );

			var destroyCalled = 0;
			var conn = createConnection();
			conn.destroy = function() {
				destroyCalled++;
			};
			server.addConnection( conn );
			conn.sendClose();

			server.destroy(function() {
				setTimeout(function() {
					assert.equal( destroyCalled, 0 );
					done();
				}, 100 );
			});
			server.closeCB();
		});
	});

	describe('doRequest', function() {

		afterEach(function() {
			nock.cleanAll();
		});

		it('should post without data', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"method": "POST"
			};

			var counter = 0;
			var scope = createServer( opts.url, 200 );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( err === undefined );
				assert.isTrue( res.statusCode === 200 );
				assert.deepEqual( res.data, ["pepe"] );
				done();
			});
		});

		it('should post without data and returns no json', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"method": "POST",
				"data": { "invalid": true }
			};

			var counter = 0;
			var scope = createServer( opts.url, 200, 'text/html' );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( err === undefined );
				assert.isTrue( res.statusCode === 200 );
				assert.deepEqual( res.data, "pepe" );
				done();
			});
		});

		it('should handle error in parsing json', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"method": "POST",
				"data": { "invalid": true }
			};

			var counter = 0;
			var scope = createServer( opts.url, 200 );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( res.statusCode === 200 );
				assert.isDefined( err );
				done();
			});
		});

		it('should post basic request', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"data": { "test": "test_response" },
				"method": "POST"
			};

			var counter = 0;
			var scope = createServer( opts.url, 200 );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( err === undefined );
				assert.isTrue( res.statusCode === 200 );
				assert.deepEqual( res.data, opts.data );
				done();
			});
		});

		it('should handle secure options', function(done) {
			var opts = {
				"url": 'https://pepe.com',
				"data": { "test": "test_response" },
				"method": "POST",
				"secure": true
			};

			var counter = 0;
			var scope = createServer( opts.url, 200 );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( err === undefined );
				assert.isTrue( res.statusCode === 200 );
				assert.deepEqual( res.data, opts.data );
				done();
			});
		});

		it('should check status code 204', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"data": { "test": "test_response" },
				"method": "POST"
			};
			var counter = 0;
			var scope = createServer( opts.url, 204 );

			tvdutil.doRequest( opts, function(err,res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isTrue( err === undefined );
				assert.isTrue( res.statusCode === 204 );
				assert.isFalse( res.data === undefined );
				assert.strictEqual( res.data.test, opts.data.test );
				done();
			});
		});

		it('should fail url doesnt exists', function(done) {
			var opts = {
				"url": 'http://pepe_no_debe_existir.com',
				"data": { "test": "test_response" },
				"method": "POST"
			};

			nock.enableNetConnect();
			tvdutil.doRequest( opts, function(err,res) {
				assert.isTrue( err !== undefined, "Shouldn't reach this point" );
				done();
			});

			setTimeout(function() {
				done();
			},500);
			nock.disableNetConnect();
		});

		it('should fail url malformed', function(done) {
			var opts = {
				"url": 'ht://pepe.com',
				"data": { "test": "test_response" },
				"method": "POST"
			};

			var counter = 0;
			var scope = createServer( 'http://pepe.com', 200 );

			tvdutil.doRequest( opts, function(err, res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isDefined( err );
				assert.strictEqual( err.message, 'Malformed url=ht://pepe.com' );
				assert.isUndefined( res );
				done();
			});
		});

		it('should fail url malformed with custom post', function(done) {
			var opts = {
				"url": 'ht://pepe.com/pepe',
				"data": { "test": "test_response" },
				"method": "POST"
			};

			var counter = 0;
			var scope = nock('http://pepe.com').post('/pepe').reply(200, function(url, requestBody) {
				return requestBody;
			});

			tvdutil.doRequest( opts, function(err, res) {
				counter++;
				assert.equal( counter, 1 );
				assert.isDefined(err);
				assert.strictEqual( err.message, 'Malformed url=ht://pepe.com/pepe' );
				assert.isUndefined( res );
				done();
			});
		});
	});

	describe('createWebService', function() {
		it ('basic test', function(done) {
			let WebModule = function() {
				return {
					name: 'pepe'
				};
			};

			let remote = {
				addModule: function() {
					return bPromise.resolve();
				},
				rmModule: function() {
					return bPromise.resolve();
				}
			};
			let adapter = {
				registry: function() {
					return {
						get: function() {
							return remote;
						}
					}
				}
			};
			let srv = tvdutil.createWebService( WebModule, adapter );
			assert(srv);
			assert(srv.onStart);
			assert(srv.onStop);

			srv.onStart(function() {
				srv.onStop(function() {
					done();
				});
			});
		});
	});

	describe('doRequestAsync', function() {
		var oldRequest = tvdutil.doRequest;

		beforeEach(function() {
			oldRequest = tvdutil.doRequest;
		});

		it( 'test resolve', function(done) {
			var opts = {
				"url": 'http://pepe.com',
				"method": "POST"
			};

			var counter = 0;
			var scope = createServer( opts.url, 200 );

			tvdutil.doRequestAsync( opts )
				.then(function(res) {
					counter++;
					assert.equal( counter, 1 );
					assert.isTrue( res.statusCode === 200 );
					assert.deepEqual( res.data, ["pepe"] );
					done();
				});
		});

		it('test reject', function(done) {
			var opts = {
				"url": 'http://pepe_no_debe_existir.com',
				"data": { "test": "test_response" },
				"method": "POST"
			};

			nock.enableNetConnect();
			tvdutil.doRequestAsync( opts )
				.catch(function(err) {
					assert.isTrue( err !== undefined, "Shouldn't reach this point" );
					done();
				});

			setTimeout(function() {
				done();
			},500);
			nock.disableNetConnect();
		});
	});
});
