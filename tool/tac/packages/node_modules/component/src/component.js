"use strict";

var assert = require("assert");
var mURL = require('url');
var bPromise = require("bluebird");
var tvdutil = require('tvdutil');

var noServices = [
	'ar.edu.unlp.info.lifia.tvd.pkgmgr',
	'ar.edu.unlp.info.lifia.tvd.srvmgr'
];

function cleanDeps( deps ) {
	return deps.filter(function(id) {
		return (noServices.indexOf(id) >= 0) ? false : true;
	});
}

function getField(info, pkgInfo, field, def) {
	if (info[field] !== undefined) {
		return info[field];
	}
	else if (pkgInfo[field] !== undefined) {
		return pkgInfo[field];
	}
	return def;
}

function Component( reg, compID ) {
	assert( reg );
	assert( compID );

	//	Get package manager
	var pkgMgr = reg.get('pkgmgr');
	assert(pkgMgr);

	//	Get component info from manifest
	var info = pkgMgr.getComponentInfo( compID );
	if (!info) {
		throw tvdutil.warnErr( 'Component', 'Component not exists: id=%s', compID );
	}

	//	Check mandatory attributes
	if (!info || !info.id || !info.name || !info.type || !info.version || !info.main || !info.pkgID) {
		throw tvdutil.warnErr( 'Component', 'Mandatory attributes missing: id=%s', compID );
	}

	//	Check type
	if (info.type != 'service' && info.type != 'app' && info.type != 'binary') {
		throw tvdutil.warnErr( 'Component', 'Invalid type value: type=%s', info.type );
	}

	//	Check if dependencies exists -> dictionary
	if (info.dependencies) {
		if (!Array.isArray(info.dependencies)) {
			throw tvdutil.warnErr( 'Component', 'Dependencies must be an array: id=%s', compID );
		}

		cleanDeps(info.dependencies).forEach(function(dep) {
			if (!pkgMgr.hasComponent( dep )) {
				throw tvdutil.warnErr( 'Component', 'Dependency not resolved: id=%s, dependency=%s', compID, dep );
			}
		});
	}

	//	Resolve icon
	if (info.icon) {
		try {
			info.iconResolved = this.resolveResource(pkgMgr,info,'icon');
		}
		catch(err) {}
	}

	//	Get package info from manifest
	var pkgInfo = pkgMgr.get(info.pkgID);
	assert(pkgInfo);

	this._registry = reg;

	//	Copy only necesary information from manifest
	this.info = {};
	this.info.id = info.id;
	this.info.pkgID = info.pkgID;
	this.info.type = info.type;
	this.info.main = info.main;
	if (info.iconResolved) {
		this.info.icon = info.iconResolved;
	}
	this.info.dependencies = info.dependencies ? info.dependencies : [];
	this.info.name = getField(info,pkgInfo,'name');
	this.info.description = getField(info,pkgInfo,'description');
	this.info.version = getField(info,pkgInfo,'version');
	this.info.vendor = getField(info,pkgInfo,'vendor');
	this.info['vendor-url'] = getField(info,pkgInfo,'vendor-url');
	this.info.system = getField(info,pkgInfo,'system',false);
	this.info.user = getField(info,pkgInfo,'user',true);

	log.silly( 'Component', 'Created component: id=%s', info.id );
}

//	API
Component.prototype.resolveResource = function(pkgMgr,info,prop) {
	assert(pkgMgr);
	assert(info);
	assert(prop);
	var val = info[prop];
	var oURL = mURL.parse( val );
	if (!oURL || (!!oURL.protocol && !/^(http|https|file|chrome):$/.exec(oURL.protocol))) {
		throw tvdutil.warnErr( 'Component', 'Property %s must be http/https/file/chrome: %s=%s', prop, prop, val );
	}

	if (!oURL.protocol || oURL.protocol == 'file:') {	//	Local file
		var p = oURL.protocol ? oURL.pathname : val;
		var res = pkgMgr.getInstallPath( info.id, p );
		if (!tvdutil.isFile(res)) {
			throw tvdutil.warnErr( 'Component', 'Property %s is local file but not exists: %s=%s', prop, prop, res );
		}
		return 'file://' + res;
	}
	else {
		return val;
	}
};

Component.prototype.dependencies = function() {
	return this.info.dependencies;
};

Component.prototype.depends = function( id ) {
	return this.dependencies().indexOf(id) >= 0;
};

Component.prototype.runDependencies = function() {
	log.verbose("Component", "runDependencies: id=%s, deps=%d", this.info.id, this.dependencies().length );

	var srvMgr = this._registry.get('srvmgr');
	var self = this;
	var deps = [];
	cleanDeps(this.dependencies()).forEach(function(dep) {
		deps.push( srvMgr.run(dep) );
	});
	return new bPromise.all(deps)
		.then(function() {
			log.silly("Component", "runDependencies end: id=%s", self.info.id );
			return self;
		});
};

Component.prototype.stopDependencies = function() {
	log.verbose("Component", "stopDependencies begin: id=%s, deps=%d", this.info.id, this.dependencies().length );

	var srvMgr = this._registry.get('srvmgr');
	var srvs = [];
	cleanDeps(this.dependencies()).forEach(function(dep) {
		srvs.push( srvMgr.stop(dep) );
	});

	//	Wait for all dependencies
	var self=this;
	return new bPromise.settle(srvs)
		.then(function() {
			return self;
		});
};

//	Exports
module.exports = Component;
