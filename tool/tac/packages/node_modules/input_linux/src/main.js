'use strict';

var assert = require('assert');
var bPromise = require('bluebird');
var fs = bPromise.promisifyAll( require('fs') );
var tvdutil = require('tvdutil');
var ioctl = require('./ioctl');


//----input.h-------------------------------------------------------------------
var EV_SYN = 0;
var EV_KEY = 1;
var EV_REL = 2;

var EV_REL_X = 0;
var EV_REL_Y = 1;

var KEY_MAX = 0x2ff;

//----uinput.h------------------------------------------------------------------
var uidevSize = 1116;

var UI_DEV_CREATE=21761;
var UI_DEV_DESTROY=21762;
var UI_SET_EVBIT=1074025828;
var UI_SET_KEYBIT=1074025829;
var UI_SET_RELBIT=1074025830;

var BUS_USB = 3;

// struct input_event {
// 	struct timeval time;
// 	__u16 type;
// 	__u16 code;
// 	__s32 value;
// };

// struct input_id {
// 	__u16 bustype;
// 	__u16 vendor;
// 	__u16 product;
// 	__u16 version;
// };

// #define UINPUT_MAX_NAME_SIZE	80
// struct uinput_user_dev {
// 	char name[UINPUT_MAX_NAME_SIZE];
// 	struct input_id id;
// 	__u32 ff_effects_max;
// 	__s32 absmax[ABS_CNT];
// 	__s32 absmin[ABS_CNT];
// 	__s32 absfuzz[ABS_CNT];
// 	__s32 absflat[ABS_CNT];
// };

var evStruct = {
	'x64': { size: 24, off: 16 },
	'arm': { size: 16, off: 8 }
};

//------------------------------------------------------------------------------


function InputService() {
	var self = {};
	var _fd = -1;
	var _findCond = null;

	function ioctlAsync( req, data ) {
		return new bPromise(function(resolv,reject) {
			var fncCallback = function(err,ret,res) {
				if (err) {
					reject(err);
				}
				else {
					assert(ret >= 0 );
					resolv(res);
				}
			};

			if (data) {
				ioctl( _fd, req, data, fncCallback );
			}
			else {
				ioctl( _fd, req, fncCallback );
			}
		});
	}

	function initEvBuffer(type, code, value) {
		var ev = evStruct[process.arch];
		assert(ev);
		var structSize = ev.size;
		var off = ev.off;

		var buffer = new Buffer(structSize);
		buffer.fill(0);

		// var time = process.hrtime();
		// off = buffer.writeUInt32LE(time[0],off);
		// off = buffer.writeUInt32LE(Math.floor(time[1]/1000),off);
		off = buffer.writeUInt16LE(type,off);
		off = buffer.writeUInt16LE(code,off);
		off = buffer.writeInt32LE(value,off);
		return buffer;
	}

	function sendKeyBuffer( code, press ) {
		return initEvBuffer( EV_KEY, code, press );
	}

	function sendMouseRelBuffer( axis, delta ) {
		return initEvBuffer( EV_REL, axis, delta );
	}

	function syncBuffer() {
		return initEvBuffer( EV_SYN, 0, 0 );
	}

	function write(buffer) {
		return fs.writeAsync( _fd, buffer, 0, buffer.length, null );
	}

	function setupUInput() {
		return fs.openAsync( "/dev/uinput", "w+" )
			.then(function(fd) {
				_fd = fd;
			})
			.then( () => ioctlAsync( UI_SET_EVBIT, EV_KEY ) )
			.then(function() {
				var proms = [];
				for (var i=1; i<KEY_MAX; i++) {
					proms.push( ioctlAsync( UI_SET_KEYBIT, i ) );
				}
				return bPromise.all(proms);
			})
			.then( () => ioctlAsync( UI_SET_EVBIT, EV_REL ) )
			.then( () => ioctlAsync( UI_SET_RELBIT, EV_REL_X ) )
			.then( () => ioctlAsync( UI_SET_RELBIT, EV_REL_Y ) )
			.then(function() {
				var buffer = new Buffer(uidevSize);
				buffer.fill(0);

				var name = "TAC uinput";
				buffer.write( name, 0, name.length, 'ascii' );

				var off = buffer.writeUInt16LE(BUS_USB,80);
				off = buffer.writeUInt16LE(1,off);
				off = buffer.writeUInt16LE(1,off);
				off = buffer.writeUInt16LE(1,off);

				return write( buffer );
			})
			.then(function() {
				return ioctlAsync( UI_DEV_CREATE );
			})
			.catch(function(err) {
				log.warn( 'input', 'Cannot setup UInput: err=%s', err.message );
				return cleanupUInput().then(function() {
					throw err;
				});
			});
	}

	function cleanupUInput() {
		if (_fd < 0) {
			return bPromise.resolve();
		}

		return ioctlAsync( UI_DEV_DESTROY )
			.catch(function(err) {
				log.warn( 'input', 'Cannot destory uinput device: err=%s', err.message );
			})
			.then( () => fs.close(_fd ) )
			.then( () => _fd = -1 );
	}

	self.sendKey = function( keyCode, isUp, cb ) {
		write( sendKeyBuffer( keyCode, isUp ? false : true ) )
			.then( ()=> write( syncBuffer() ) )
			.then( ()=> cb(), cb );
	};

	self.sendMouseMove = function( deltaX, deltaY, cb ) {
		write( sendMouseRelBuffer( EV_REL_X, deltaX ) )
			.then( ()=> write( sendMouseRelBuffer( EV_REL_Y, deltaY ) ) )
			.then( ()=> write( syncBuffer() ) )
			.then( ()=> cb(), cb );
	};

	self.name = function() {
		return 'devinput (linux)';
	};

	self.start = function(cb) {
		_findCond = new tvdutil.BasicWaitCondition();
		_findCond.inc();

		setupUInput()
			.then(function() {
				_findCond.dec();
				if (cb) {
					cb(true);
				}
			}, function() {
				_findCond.dec();
				if (cb) {
					cb(false);
				}
			});

		return true;
	};

	self.stop = function(cb) {
		assert(cb);
		assert(_findCond);

		_findCond.wait(function() {
			cleanupUInput()
				.then( () => cb(), cb );
		});
	};

	return Object.freeze(self);
}

module.exports = InputService;

