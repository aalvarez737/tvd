'use strict';

var path = require('path');
var util = require('util');
var assert = require('assert');
var EventEmitter = require('events').EventEmitter;
var _ = require('lodash');
var bPromise = require('bluebird');
var tvdutil = require('tvdutil');
var Registry = require('registry');
var http = require('http');
var fs = require('fs');

var base_ro = '/system/original/';
var base_rw = '/system/data/';

function RecoveryError(message) {
	Error.call(this);
	Error.captureStackTrace(this, this.constructor);
	this.name = this.constructor.name;
	this.message = message;
}
util.inherits(RecoveryError, Error);

function TacMock() {
	var _inDev = false;
	var self = {};

	//	Shutdown methods
	self.updateFirmware = function(/*url,now*/) {};
	self.factoryReset = function() {};
	self.reboot = function() {};
	self.powerOff = function() {};

	//	Development mode
	self.inDevelopmentMode = function() {
		return _inDev;
	};
	self.enableDevelopmentMode = function(st) {
		_inDev = st;
	};

	//	License/first boot
	self.firstBoot = true;
	self.isFirstBoot = function() {
		return self.firstBoot;
	};
	self.licenseAccepted = function() {
		self.firstBoot = false;
	};

	//	System paths
	self.getDataRootPath = function() {
		return base_rw;
	};

	self.getInstallRootPath = function() {
		return base_ro;
	};

	//	Information
	self.platform = {
			name: 'UNKNOWN',
			version: '0.0.0',
			commit: '0'
	};
	self.getPlatform = function() {
		return self.platform;
	};

	self.getSystemVersion = function() {
		return {
			api: 1,
			version: "1.0.0",
			commit: "na"
		};
	};

	self.serial = '1';
	self.getSerial = function() {
		return self.serial;
	};

	return self;
}

function mockRequire( modRequire, requestedModule, mockedModules, cond ) {
	var origRequire = module.constructor.prototype.require;

	if (cond === undefined) {
		cond = true;
	}

	module.constructor.prototype.require = function(p) {
		//console.log( 'p=%s, cond=%s, mockedModules[p]=%s', p, cond, mockedModules[p] );
		if (cond && mockedModules[p] !== undefined) {
			return mockedModules[p];
		}
		return this.constructor._load(p, this);
	};

	//	Delete requested module from so you get a new module every time
	var modName = modRequire.resolve( requestedModule );
	var mod = modRequire( modName );
	assert(mod);
	delete modRequire.cache[modName];

	//	Restore original require function
	module.constructor.prototype.require = origRequire;

	return mod;
}

function init( level ) {
	//	Register global tac
	global.tac = new TacMock();

	//	Register RecoveryError
	global.RecoveryError = RecoveryError;

	tvdutil.setupLog( level ? level : 'info' );

	return new Registry();
}

function fin() {
	global.log = null;
}

function rwPath(path_to_rw) {
	if (path_to_rw){
		base_rw = path_to_rw;
	}
	return base_rw;
}

function roPath( path_to_ro ) {
	if (path_to_ro){
		base_rw = path_to_ro;
	}
	return base_ro;
}

function createApp( id, withComponents ) {
	if (withComponents === undefined) {
		withComponents = true;
	}

	var app = {};

	app.id = 'ar.edu.unlp.info.lifia.tvd.' + id;

	if (withComponents) {
		app.component = {
			'id': app.id,
			'pkgID': app.id,
			'name': 'Test App',
			'type': 'app',
			'version': '1.0.0',
			'vendor': 'PEPE',
			'vendor-url': 'http://pepe.com/',
			'description': 'A description',
			'categories': ['prueba','System', 'favoritos'],
			'main': 'main.html',
			'bg_transparent': true,
			'icon': 'icon.png',
			'extra_ua': ''
		};

		app.componentParsed = {
			'id': app.id,
			'pkgID': app.id,
			'name': 'Test App',
			'type': 'app',
			'version': '1.0.0',
			'vendor': 'PEPE',
			'user': true,
			'system': false,
			'vendor-url': 'http://pepe.com/',
			'categories': ['PRUEBA','SYSTEM', 'FAVORITOS'],
			'description': 'A description',
			'main': 'file:///system/original/packages/' + app.id + '/main.html',
			'icon': 'file:///system/original/packages/' + app.id + '/icon.png',
			'bg_transparent': true,
			'enable_mouse': false,
			'enable_geolocation': false,
			'hw_codecs_only': false,
			'dependencies': [],
			'plugins': [],
			'extra_ua': ''
		};
	}

	app.manifest = {
		'id': app.id,
		'vendor': 'LIFIA',
		'vendor-url': 'http://lifia.info.unlp.edu.ar/',
		'categories': ['prueba','system'],
		'version': '1.0.0',
		'api-level': '1.0',
		'platform': 'all',
		'components': withComponents ? [app.component] : []
	};

	app.installPath = path.join( base_ro, 'packages', app.id );
	app.installDir = {
		'manifest.json': JSON.stringify( app.manifest, null, 4 ),
		'main.html': '<html></html>',
		'icon.png': 'binary_value'
	};

	return app;
}

function changeCategories( app, categories ) {
	app.component.categories = categories;
	app.componentParsed = categories.map(function(str) { return str.toUpperCase(); });
}

function NotificationService() {
	var self = this || {};
	var events = new EventEmitter();

	tvdutil.forwardEventEmitter(self, events);
	self.on.isSignal = true;
	self.on.unregisterMethod = self.removeListener;
	self.once.isSignal = true;

	self.getWebAPI = function() {
		return {
			'name': 'notification',
			'public': ['on', 'once', 'emit'],
		};
	};

	return self;
}

function PackageManager(pkgs) {
	var self = {};
	var _pkgs = pkgs;
//	console.log( 'pkgs=%j', pkgs );
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(self, events);

	self.setPkgs = function(p) {
		_pkgs = p;
	};

	self.getPkgs = function() {
		return _pkgs;
	};

	self.uninstall = function( id, cb ) {
		tvdutil.emitThen( events, 'uninstall', id )
			.then(function() {
				cb(id);
			});
	};

	self.canUninstall = function( /*id*/ ) {
		return true;
	};

	self.install = function(options,cb) {
		if (options.id) {
			tvdutil.emitThen( events, 'install', options.id ).then(function() {
				cb(undefined,options.id);
			}, cb);
		} else {
			cb( new Error('mocks') );
		}
	};

	self.installEx = function(manifest,cb) {
		assert(manifest.id);
		var man = _.cloneDeep(manifest);
		_pkgs.push(man);
		//console.log( 'instalEx: pre install pkgs=%j', _pkgs );
		self.install( { id: manifest.id }, cb );
	};

	self.update = function(options,cb) {
		if (options.id) {
			//console.log( 'send begin' );
			tvdutil.emitThen( events, 'update', options.id ).then(function() {
				//console.log( 'send end' );
				events.emit( 'updated', options.id );
				cb(undefined,options.id);
			}, cb);
		} else {
			cb( new Error('mocks') );
		}
	};

	self.hasPackage = function( pkgID ) {
		for (var i=0; i<_pkgs.length; i++) {
			if (_pkgs[i].id === pkgID) {
				return true;
			}
		}
		return false;
	};

	self.getComponents = function( pkgID, type ) {
		var comps = [];
		for (var i=0; i<_pkgs.length; i++) {
			if (_pkgs[i].id === pkgID) {
				for (var j=0; j<_pkgs[i].components.length; j++) {
					if (!type || _pkgs[i].components[j].type === type) {
						comps.push( pkgs[i].components[j] );
					}
				}
			}
		}
		return comps;
	};

	self.hasComponent = function( id ) {
		var comp = self.getComponentInfo(id);
		return comp ? true : false;
	};

	self.getAllComponentsInfo = function(type) {
		var comps = [];
		for (var i=0; i<_pkgs.length; i++) {
			for (var j=0; j<_pkgs[i].components.length; j++) {
				if (!type || _pkgs[i].components[j].type === type) {
					comps.push( _pkgs[i].components[j] );
				}
			}
		}
		return comps;
	};

	self.getComponentInfo = function( id ) {
		var result;
		for (var i=0; i<_pkgs.length; i++) {
			for (var j=0; j<_pkgs[i].components.length; j++) {
				if (_pkgs[i].components[j].id === id) {
					result = _pkgs[i].components[j];
					break;
				}
			}
		}
		//console.log( 'call to getComponentInfo: id=%s, result=%j', id, result );
		return result;
	};

	self.get = function( pkgID ) {
		var result;
		for (var i=0; i<_pkgs.length; i++) {
			if (_pkgs[i].id === pkgID) {
				result = _pkgs[i];
				break;
			}
		}
		//console.log( 'call to get: id=%s, result=%j', pkgID, result );
		return result;
	};

	self.getAll = function() {
		return _.keys(_pkgs);
	};

	self.getAllInfo = function() {
		var result=[];
		for (var i=0; i<_pkgs.length; i++) {
			result.push( _pkgs[i] );
		}
		return result;
	};

	self.getInstallPath = function(id) {
		var params = Array.prototype.slice.call(arguments,1);
		params.unshift( path.join(base_ro,'packages/',id) );
		return path.join.apply(path,params);
	};

	self.getDataPath = function(id) {
		var params = Array.prototype.slice.call(arguments,1);
		params.unshift( path.join(base_rw,'config',id) );
		return path.join.apply(path,params);
	};

	self.getWebAPI = function() {
		return {
			'name': 'pkgmgr',
			'public': ['getAll','hasPackage', 'on'],
			'private': ['install','uninstall']
		};
	};

	return self;
}

function Screen() {
	var self = this || {};
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(self, events);

	var _active = false;

	//	Setup
	self.setActive = function( st ) {
		if (_active !== st ) {
			//console.log( 'setActive: st=%d', st );
			_active = st;
			events.emit( 'changed', st );
		}
	};

	self.name = function() {
		return 'mock';
	};

	self.setProvider = function() {
	};

	self.isActive = function() {
		//console.log( "isActive=%d", _active );
		return _active;
	};

	self.turnOn = function() {
		self.setActive( true );
	};
	self.turnOff = function() {
		self.setActive( false );
	};

	return Object.freeze(self);
}

function Input() {
	var self = this || {};

	//	Setup
	self.sendKey = function() {
	};

	return self;
}

function ApplicationManager() {
	var self = {};
	var apps = {};

	self.addInstance = function( id ) {
		var app = { info: { user: false } };
		apps[id] = app;
		//console.log( 'addInstance: app=%j', app );
		return app;
	};

	self.rmInstance = function( id, cb ) {
		//console.log( 'rmInstance: id=%s', id );
		delete apps[id];
		cb();
	};

	self.get = function(id) {
		return apps[id];
	};

	return self;
}

function ServiceManager() {
	var self = {};
	var _ready = false;
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(self, events);

	self.result = {
		runs: [],
		stops: []
	};

	self.services = {};

	self.run = function(id) {
		self.result.runs.push(id);
		return true;
	};

	self.isRunning = function(id) {
		//console.log( "runs=%j", self.result.runs );
		return self.result.runs.indexOf(id) >= 0;
	};

	self.stop = function(id) {
		self.result.stops.push(id);
		return new bPromise.resolve();
	};

	self.getAllRunning = function() {
		return self.result.runs;
	};

	self.getAll = function() {
		return self.result.runs + self.result.stops;
	};

	self.get = function(id) {
		return self.services[id];
	};

	self.getDependencies = function(id) {
		return (self.services[id]) ? self.services[id].dependencies : [];
	};

	self.getConfigApp = function(id) {
		if (self.services[id]) {
			return self.services[id].configure;
		}
	};

	self.isReady = function() {
		return _ready;
	};

	self.ready = function(st, cb) {
		if (st !== _ready) {
			_ready = st;
			if (cb) {
				tvdutil.emitThen(events, 'ready', st).then(cb);
			} else {
				events.emit( 'ready', st );
			}
		}
	};

	self.dump = function(/*id*/) {
		return {};
	};

	self.getWebAPI = function() {
		return {
			'name': 'srvmgr',
			'public': [
				'getAll',
				'get'
			],
		};
	};

	return self;
}

function ServiceAdapter(reg, pkgName) {
	pkgName = pkgName ? pkgName : 'ar.edu.unlp.info.lifia.tvd.any';

	//	API
	var self = {};
	self.info = function() {
		return {
			name: 'system',
			description: 'System Api',
			version: '1.0.0.na'
		};
	};
	self.getInstallPath = function () {
		var params = Array.prototype.slice.call(arguments, 0);
		params.unshift( path.join(base_rw,'packages',pkgName) );
		return path.join.apply(path,params);
	};

	self.getDataPath = function() {
		var params = Array.prototype.slice.call(arguments, 0);
		params.unshift( path.join(base_rw,'config',pkgName) );
		return path.join.apply(path,params);
	};
	self.getInstallRootPath = function() { return base_ro; };
	self.getDataRootPath = function() { return base_rw; };
	self.getSharePath = function() { return path.join(self.getDataRootPath(),'share'); };
	self.getTemporaryPath = function() { return '/tmp'; };
	self.registry = function() { return reg; };
	self.load = function( file, defaultsValues ) { return defaultsValues; };
	self.save = function( /*file, config*/ ) {};
	return self;
}

function Audio() {
	var self = this || {};

	self.toggleMute = function() {
	};

	self.volumeDown = function() {
	};

	self.volumeUp = function() {
	};

	return self;
}

function BasicBrowser(/*reg*/) {
	var browser = {};
	var _ready = false;
	var _objs = {};
	var _lastID = 0;
	var _ret = null;
	var _auto = false;
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(browser, events);

	browser.sendEvent = function( id, evt, sync ) {
		if (sync) {
			assert(_objs[id]);
			assert(_objs[id].onEvent);
			_objs[id].onEvent( evt );
		}
		else {
			process.nextTick( function() {
				assert(_objs[id]);
				assert(_objs[id].onEvent);
				_objs[id].onEvent( evt );
			});
		}
	};

	browser.isReady = function() {
		return _ready;
	};

	browser.ready = function(st) {
		_ready = st;
		events.emit( 'ready', st );
	};

	browser.launchBrowser = function( url, options, onEvent ) {
		if (_ret) {
			return _ret;
		}
		else {
			_lastID++;
			_objs[_lastID] = { 'onEvent': onEvent };
			if (_auto) {
				browser.notifyUp(_lastID);
			}

			return _lastID;
		}
	};

	browser.closeBrowser = function( id ) {
		assert(_objs[id]);
		if (_auto) {
			browser.closeEvent(id);
		}
	};

	browser.showBrowser = function( /*id, show*/ ) {
	};

	browser.launchedEvent = function(id) {
		browser.sendEvent( id, { 'name': 'onLaunched' } );
	};

	browser.loadedEvent = function(id) {
		browser.sendEvent( id, { 'name': 'onLoaded' } );
	};

	browser.closedEvent = function(id) {
		browser.sendEvent( id, { 'name': 'onClose' } );
	};

	browser.closeEvent = function( browserID, err ) {
		browser.sendEvent( browserID, { 'name': 'onClose', 'error': err } );
	};

	browser.notifyUp = function(id) {
		browser.launchedEvent(id);
		browser.loadedEvent(id);
	};

	browser.sendKey = function( id, key ) {
		browser.sendEvent( id, {name: 'onKey', isUp: false, code: key});
		browser.sendEvent( id, {name: 'onKey', isUp: true, code: key});
	};

	browser.apiEvent = function( id, srvID, method, params, resultCB ) {
		browser.sendEvent( id, {
			'name': 'onAPI',
			'serviceID': srvID,
			'method': method,
			'params': params,
			'resultCB': resultCB
		});
	};

	browser.apiEvent2 = function( id, srvID, apiName, method, params, resultCB ) {
		browser.sendEvent( id, {
			'name': 'onAPI',
			'serviceID': srvID,
			'apiName': apiName,
			'method': method,
			'params': params,
			'resultCB': resultCB
		});
	};

	browser.setLauncherReturn = function( ret ) {
		_ret = ret;
	};

	browser.doAuto = function(/*st*/) {
		_auto = true;
	};

	return browser;
}

function Factory() {
	var self = {};
	var _cfg = {
		'backendURL': 'http://www.pepe.com',
		'keyboardLayout': {'VK_ENTER': { 'virtual': 13, 'raw': 28 }},
		'mouseLayout': {'BTN_LEFT': { 'raw': 272 }},
		'htmlshell': {'cmd': 'htmlshell'},
		'shellID': 'ar.edu.unlp.info.lifia.tvd.shell',
		'build': {'name': 'Desarrollo', 'file': 'dev.conf', 'type': 'debug', 'config': 'dev'}
	};

	self.createAudio = function() {
		return null;
	};

	self.createInput = function() {
		return null;
	};

	self.getConfig = function(key) {
		return _cfg[key];
	};

	self.addConfig = function( key, val ) {
		_cfg[key] = val;
	};

	return self;
}

function System() {
	var self = {};
	var _sendCrash = null;

	function defaultConfig() {
		return {
			enabled: false,
			maxHistorySize: 1000,
			maxWidth: null, // Disable maxWidth
			level: 'info'
		};
	}

	self.devModeEnabled = true;

	self.isDevelopmentMode = function() {
		return self.devModeEnabled;
	};

	self.getInfo = function() {
		return {
			id: '1',
			system: {version: '1.0.XXXX'},
			platform: {name: 'Test'}
		};
	};

	self.setLogConfig = function() {};
	self.sendError = function() {};
	self.setReportCallback = function(cb) {
		_sendCrash = cb;
	};
	self.sendReport = function(crashInfo) {
		if (_sendCrash) {
			_sendCrash(crashInfo);
		}
	};

	self.on = function() {};
	self.on.isSignal = true;
	self.removeListener = function( /*sig, cb*/ ) {};
	self.unregisterSignal = function() {};

	self.getRemotePort = function() {
		return 1080;
	};

	self.getLogConfig = function() {
		return defaultConfig();
	};

	self.getWebAPI = function() {
		return {
			'name': 'system',
			'public': ['getInfo', 'on']
		};
	};

	return self;
}

function CheckRecoveryError( expectedMsg, done ) {
	// Replace mocha handler until we catch de expected error
	var mochaHandler = process.listeners('uncaughtException').pop();
	if (mochaHandler) {
		process.removeListener('uncaughtException', mochaHandler);
	}
	process.once('uncaughtException', function(err) {
		if (mochaHandler) {
			process.listeners('uncaughtException').push(mochaHandler);
		}
		if ((err instanceof RecoveryError) && (expectedMsg === err.message)) {
			done();
		} else {
			done(err);
		}
	});
}

function NetworkManager() {
	var self = {};
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(self, events);

	self.activeConnection = function(cb) {
		cb( undefined, { ip: '127.0.0.1/24' } );
	};

	self.notify = function( conn ) {
		events.emit( 'active', conn );
	};

	return self;
}

function DiskManager() {
	var self = {};
	var _signals = {};
	var _disks = {};

	self.on = function( s, handler ) {
		_signals[s] = handler;
	};
	self.emit = function( s, evt ) {
		_signals[s]( evt );
	};
	self.addDisk = function(d) {
		_disks[d.id] = d;
		self.emit( 'added', d.id );
	};
	self.rmDisk = function(id) {
		delete _disks[id];
		self.emit( 'removed', id );
	};
	self.removeListener = function( s ) {
		delete _signals[s];
	};
	self.enumerateDevices = function(cb) {
		cb( undefined, Object.keys(_disks) );
	};
	self.get = function(id,cb) {
		cb( undefined, _disks[id] );
	};
	self.diskInfo = function( id, label, mount ) {
		return {
			id: id,
			drive: {
				vendor: 'vendor',
				model: 'pepe',
				revision: 'pepe1',
				serial: 'pepe2'
			},
			label: label,
			mountPaths: mount ? [mount] : []
		};
	};

	return self;
}

function Provider() {
	this.providers = {};

	//	Api
	this.addProvider = function(p) {
		this.providers[p.id] = p;
	};

	this.hasProvider = function(pID) {
		return this.providers[pID] ? true : false;
	};

	this.rmProvider = function(n) {
		delete this.providers[n];
	};

	this.get = function(opts, cb) {
		var p = this.providers[opts.provider];
		if (p) {
			p.get(opts).then(function(res) {
				cb(undefined,res);
			},cb);
		} else {
			cb(new Error('Provider not found: ' + opts.provider));
		}
	};
}

function RemoteApi() {
	var self = {};
	self.modules = {};
	self.addModule = function(mod) {
		self.modules[mod.name] = mod;
		return bPromise.resolve();
	};
	self.rmModule = function(name) {
		delete self.modules[name];
		return bPromise.resolve();
	};
	return self;
}

function Downloader() {
	var self = {};
	var events = new EventEmitter();
	tvdutil.forwardEventEmitter(self, events);

	return self;
}

function createServer( baseDir, user, pass ) {
	let server = http.createServer(function (request, response) {
		var filePath = path.join(baseDir,request.url);
		console.log('request: %s, file=%s', request.url, filePath );		

        if (user && pass) {
			var auth = request.headers.authorization;
			if (!auth) {
				// No Authorization header was passed in so it's the first time the browser hit us
				// Sending a 401 will require authentication, we need to send the 'WWW-Authenticate' to tell them the sort of authentication to use
				// Basic auth is quite literally the easiest and least secure, it simply gives back  base64( username + ":" + password ) from the browser
				response.statusCode = 401;
				response.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"');
				response.end('<html><body>Need some creds son</body></html>');
				return;
			}
			else {
				// Split on a space, the original auth looks like  "Basic Y2hhcmxlczoxMjM0NQ==" and we need the 2nd part
				var tmp = auth.split(' ');
                var buf = new Buffer(tmp[1], 'base64'); // create a buffer and tell it the data coming in is base64
                var plain_auth = buf.toString();        // read it back out as a string

                // At this point plain_auth = "username:password"
                var creds = plain_auth.split(':');      // split on a ':'
                var username = creds[0];
                var password = creds[1];
				console.log( 'user=%s, pass=%s', username, password );
				if (username !== user || pass !== password) {
					response.writeHead(500);
					response.end('Invalid user/pass\n');
					response.end();
					return;
				}
			}
        }

		var extname = String(path.extname(filePath)).toLowerCase();
		var contentType = 'text/html';
		var mimeTypes = {
			'.html': 'text/html',
			'.js': 'text/javascript',
			'.css': 'text/css',
			'.json': 'application/json',
			'.png': 'image/png',
			'.jpg': 'image/jpg',
			'.gif': 'image/gif',
			'.wav': 'audio/wav',
			'.mp4': 'video/mp4',
			'.woff': 'application/font-woff',
			'.ttf': 'application/font-ttf',
			'.eot': 'application/vnd.ms-fontobject',
			'.otf': 'application/font-otf',
			'.svg': 'application/image/svg+xml'
		};

		contentType = mimeTypes[extname] || 'application/octect-stream';

		fs.readFile(filePath, function(error, content) {
			if (error) {
				console.log( 'err=%s', error.message );
				
				response.writeHead(500);
				response.end('Sorry, check with the site admin for error: '+error.code+' ..\n');
				response.end();
			}
			else {
				response.writeHead(200, { 'Content-Type': contentType });
				response.end(content, 'utf-8');
			}
		});

	});
	server.listen(8125);
	console.log('Server running at http://127.0.0.1:8125/');
	return server;
}

module.exports.init = init;
module.exports.fin = fin;
module.exports.mockRequire = mockRequire;
module.exports.CheckRecoveryError = CheckRecoveryError;
module.exports.rwPath = rwPath;
module.exports.roPath = roPath;
module.exports.createApp = createApp;
module.exports.changeCategories = changeCategories;
module.exports.NetworkManager = NetworkManager;
module.exports.Factory = Factory;
module.exports.System = System;
module.exports.Audio = Audio;
module.exports.Screen = Screen;
module.exports.Input = Input;
module.exports.PackageManager = PackageManager;
module.exports.ServiceManager = ServiceManager;
module.exports.ServiceAdapter = ServiceAdapter;
module.exports.BasicBrowser = BasicBrowser;
module.exports.NotificationService = NotificationService;
module.exports.ApplicationManager = ApplicationManager;
module.exports.Provider = Provider;
module.exports.DiskManager = DiskManager;
module.exports.RemoteApi = RemoteApi;
module.exports.Downloader = Downloader;
module.exports.createServer = createServer;

