'use strict';

var Registry = require("../src/registry");
var Mocks = require("mocks");
var bPromise = require("bluebird");
var chai = require("chai");
chai.config.includeStack = true;
var assert = chai.assert;

describe('registry', function() {
	var registry = null;

	beforeEach(function() {
		Mocks.init('verbose');
		registry = Registry();
		registry.put('srvmgr', new Mocks.ServiceManager());
		registry.put('pkgmgr', new Mocks.PackageManager());
	});

	afterEach(function() {
		registry = null;
		Mocks.fin();
	});

	describe('constructor', function() {
		it('should construct a registry', function() {
			assert.isObject(registry);
		});
	});

	describe('put', function() {
		it('should add a service', function() {
			registry.put('some.id', {value: '10'});
			assert.isTrue(registry.has('some.id'));
		});

		it('should throw when try to add twice the same id', function() {
			registry.put('some.id', {value: '10'});
			assert.throw(function() { registry.put('some.id', {value: '10'}); }, Error, 'Api already exists: apiID=some.id' );
		});

		it('should throw when try to add a non object', function() {
			assert.throw(function() { registry.put('some.id', 10); }, Error, 'Api must be a object: apiID=some.id' );
		});

		it('should throw when try to add a API with a non function getWebAPI', function() {
			let api = {
				getWebAPI: {}
			};
			assert.throw(function() { registry.put('some.id', api); }, Error, 'getWebAPI must be a function: apiID=some.id' );
		});

		it('should throw when try to add a Web API without name', function() {
			let api = {
				getWebAPI: function() {
					return {};
				}
			};
			assert.throw(function() { registry.put('some.id', api); }, Error, 'getWebAPI must return a object with a name property: apiID=some.id' );
		});

		it('should throw when webAPI returns a non-array public methods', function() {
			let api = {
				getWebAPI: function() {
					return {
						name: 'api1',
						'public': {}
					};
				}
			};
			assert.throw(function() { registry.put('some.id', api); }, Error, 'getWebAPI must return a object with public methods as array: apiID=some.id' );
		});

		it('should throw when webAPI returns a non-array private methods', function() {
			let api = {
				getWebAPI: function() {
					return {
						name: 'api1',
						'private': {}
					};
				}
			};
			assert.throw(function() { registry.put('some.id', api); }, Error, 'getWebAPI must return a object with private methods as array: apiID=some.id' );
		});

		it('should throw when any webAPI function is not in api', function() {
			let api = {
				method1: function() {
				},
				method2: function() {
				},
				getWebAPI: function() {
					return {
						name: 'api1',
						'public': ['method1', 'meth2']
					};
				}
			};
			assert.throw(function() { registry.put('some.id', api); }, Error, 'Web exported methods must exists: apiID=some.id, method=meth2' );
		});

		it('should register a base service when it has no domain', function() {
			registry.put('some', {value: '10'});
			assert.isTrue(registry.has('ar.edu.unlp.info.lifia.tvd.some'));
		});
	});

	describe('remove', function() {
		it('should add/remove a service', function() {
			var count_added=0;
			var count_remove=0;
			registry.on( 'added', function ( id ) {
				assert.isTrue( id === 'some.id' );
				count_added++;
			});
			registry.on( 'remove', function ( id ) {
				assert.isTrue( id === 'some.id' );
				count_remove++;
			});
			registry.put('some.id', {value: '10'});
			assert.isTrue( count_added === 1 );
			assert.isTrue( count_remove === 0 );
			registry.remove( 'some.id' );
			assert.isTrue( count_added === 1 );
			assert.isTrue( count_remove === 1 );
		});
	});

	describe('get', function() {
		it('should return a service when it is in the registry', function() {
			var api = {value: '10'};
			registry.put('some.id', api);
			assert.deepEqual(registry.get('some.id'), api);
		});

		it('should return null when the service id it is not in the registry', function() {
			registry.put('some.id', {value: '10'});
			assert.isUndefined(registry.get('another.id'));
		});

		it('should return a base service when query for an id without domain', function() {
			var api = {'key': 'value'};
			registry.put('ar.edu.unlp.info.lifia.tvd.api', api);
			assert.deepEqual(registry.get('api'), api);
		});

		it('should return a base service when query for an id without domain inverted', function() {
			var api = {'key': 'value'};
			registry.put('api', api);
			assert.deepEqual(registry.get('ar.edu.unlp.info.lifia.tvd.api'), api);
		});
	});

	describe('has', function() {
		it('should return true when the service is in the registry', function() {
			registry.put('some.id', {value: '10'});
			assert.isTrue(registry.has('some.id'));
		});

		it('should return true when query for a registered base service without using the domain', function() {
			var api = {'key': 'value'};
			registry.put('ar.edu.unlp.info.lifia.tvd.api', api);
			assert.isTrue(registry.has('api'));
		});

		it('should return false when the service is not in the registry', function() {
			assert.isFalse(registry.has('no.id'));
		});
	});

	describe('swap', function() {
		it('should swap api and return old api', function() {
			var oldApi = {value: '10'};
			registry.put('some.id', oldApi);
			assert.isTrue(registry.has('some.id'));
			assert.deepEqual(registry.get('some.id'), oldApi);
			var newApi = {value: '20'};
			assert.deepEqual(registry.swap('some.id', newApi), oldApi);
			assert.isTrue(registry.has('some.id'));
			assert.deepEqual(registry.get('some.id'), newApi);
		});
	});

	describe('getWebApis', function() {
		function createAPI() {
			return {
				pub_method1: function() {},
				pub_method2: function() {},
				priv_method1: function() {},
				priv_method2: function() {},
				getWebAPI: function() {
					return {
						'name': 'apiName',
						'public': ['pub_method1', 'pub_method2'],
						'private': ['priv_method1', 'priv_method2']
					};
				}
			};
		};

		it('should return empty array if there is no web api', function() {
			assert.deepEqual(registry.getWebApis( ['app1.id'] ), []);
		});

		it('should return empty array if no web api registered', function() {
			registry.put('some.id', {value: '10'});
			assert.deepEqual(registry.getWebApis( ['some.id'] ), []);
		});

		it('should return an array with the public registered web api', function() {
			registry.put('some.id', createAPI() );
			assert.deepEqual(registry.getWebApis( ['some.id']), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1', 'pub_method2']
			}]);
		});

		it('should return an array with the public registered web api not using domain', function() {
			registry.put('api1', createAPI() );
			assert.deepEqual(registry.getWebApis( ['api1']), [{
				name: 'apiName',
				id: 'api1',
				exports: ['pub_method1', 'pub_method2']
			}]);
		});

		it('should return an array with the composed public registered web api ', function() {
			let api = {
				pub_method1: function() {},
				pub_method2: function() {},
				priv_method1: function() {},
				priv_method2: function() {},
				subAPI1: {
					pub_method3: function() {},
					pub_method4: function() {}
				},
				getWebAPI: function() {
					return {
						'name': 'apiName',
						'public': ['pub_method1', 'pub_method2', 'subAPI1.pub_method3', 'subAPI1.pub_method4'],
						'private': ['priv_method1', 'priv_method2']
					};
				}
			};
			registry.put('some.id', api );
			assert.deepEqual(registry.getWebApis( ['some.id'] ), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1', 'pub_method2','subAPI1.pub_method3', 'subAPI1.pub_method4']
			}]);
		});


		it('should return an array with the public and private registered web api if have permission', function() {
			registry.put('some.id', createAPI() );
			assert.deepEqual(registry.getWebApis( ['some.id'], {all:true} ), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1', 'pub_method2','priv_method1', 'priv_method2']
			}]);
		});

		it('should return an array with the registered web api exporting all the methods when the public and private keys not defined', function() {
			let api = createAPI();
			api.getWebAPI = function() {
				return { 'name': 'apiName' };
			};
			registry.put('some.id', api );
			assert.deepEqual(registry.getWebApis( ['some.id'] ), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1', 'pub_method2','priv_method1', 'priv_method2']
			}]);
		});

		it('should return an empty array with the registered web api if private methods are defined', function() {
			let api = createAPI();
			api.getWebAPI = function() {
				return {
					'name': 'apiName',
					'private': ['priv_method1', 'priv_method2']
				};
			};

			registry.put('some.id', api );
			assert.deepEqual(registry.getWebApis( ['some.id'] ), [{
				name: 'apiName',
				id: 'some.id',
				exports: []
			}]);
		});

		it('should return an array with two web apis', function() {
			registry.put('some.id', createAPI() );

			let api1 = createAPI();
			api1.getWebAPI = function() {
				return {
					'name': 'api1',
					'public': ['pub_method1', 'pub_method2'],
					'private': ['priv_method1', 'priv_method2']
				};
			};
			registry.put('another.id', api1 );

			assert.deepEqual(registry.getWebApis(['some.id','another.id']), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1', 'pub_method2']
			},{
				name: 'api1',
				id: 'another.id',
				exports: ['pub_method1', 'pub_method2']
			}]);
		});

		it('should grant private methods on api level', function() {
			registry.put('some.id', createAPI() );

			let api1 = createAPI();
			api1.getWebAPI = function() {
				return {
					'name': 'api1',
					'public': ['pub_method1', 'pub_method2'],
					'private': ['priv_method1', 'priv_method2']
				};
			};
			registry.put('some.api1', api1 );

			let grantOptions = {
				all: false,
				api: ['some.id']
			};
			assert.deepEqual(registry.getWebApis(['some.id','some.api1'], grantOptions), [{
				name: 'apiName',
				id: 'some.id',
				exports: ['pub_method1','pub_method2','priv_method1', 'priv_method2']
			},{
				name: 'api1',
				id: 'some.api1',
				exports: ['pub_method1', 'pub_method2']
			}]);
		});
	});

	describe('runAPI', function() {
		var evt = null;

		beforeEach(function() {
			evt = {
				serviceID: 'ar.edu.unlp.info.lifia.tvd.test_service',
				method: 'testMethod',
				resultCB: function() {},
				appID: 'ar.edu.unlp.info.lifia.tvd.test_app'
			};
		});

		it('should call resultCB with error if service not found', function(done) {
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Service not found');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with error if service not export api', function(done) {
			registry.put('test_service', {});
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Service not exported');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with error if service dont export method', function(done) {
			let api = {
				testMethod2: function() {},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod2']
					};
				}
			};
			registry.put('test_service', api );
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Method not exists');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with error if service dont pass apiName', function(done) {
			let api = {
				testMethod2: function() {},
				subApi: {
					testMethod3: function() {},
					getWebAPI: function() {
						return {
							'name': 'testsrv1',
							'public': ['testMethod3']
						};
					}
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'modules': ['subApi'],
						'public': ['testMethod2']
					};
				}
			};
			registry.put('test_service', api );
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Invalid parameter apiName');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with error if api not exists', function(done) {
			let api = {
				testMethod2: function() {},
				subApi: {
					testMethod3: function() {},
					getWebAPI: function() {
						return {
							'name': 'testsrv1',
							'public': ['testMethod3']
						};
					}
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'modules': ['subApi'],
						'public': ['testMethod2']
					};
				}
			};
			registry.put('test_service', api );
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=testsrv2, method=testMethod, err=Service API not exported');
				assert.isFalse(resp.isSignal);
				done();
			};
			evt.apiName = 'testsrv2';
			registry.runAPI(evt);
		});

		it('should call resultCB if method from service exported was called and dont return anything', function(done) {
			registry.put('test_service', {
				testMethod: function() {},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			});
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isUndefined(resp.error);
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB if service export all methods', function(done) {
			registry.put('test_service', {
				testMethod: function() {},
				getWebAPI: function() {
					return {
						name: 'testsrv'
					};
				}
			});
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert.isUndefined(resp.error);
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should not call resultCB if service exports private methods and does not have private access', function(done) {
			registry.put('test_service', {
				testMethod: function() {},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': [],
						'private': ['testMethod']
					};
				}
			});
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.data);
				assert(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Method not exists');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB if service exports private methods and call from privileged app', function(done) {
			registry.put('test_service', {
				testMethod: function() {
					return 'test_private';
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': [],
						'private': ['testMethod']
					};
				}
			});
			evt.security = { all: true };
			evt.resultCB = function(resp) {
				assert.equal(resp.error);
				assert.equal(resp.data,'test_private');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with data if service exported method was called and return something', function(done) {
			registry.put('test_service', {
				testMethod: function() { return 'response from test_service.testMethod()'; },
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			});
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isDefined(resp.data);
				assert.equal(resp.data, 'response from test_service.testMethod()');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should inject app id if method has insertId setted', function(done) {
			var testSrv = {
				testMethod: function(id) {
					assert.strictEqual( id, 'ar.edu.unlp.info.lifia.tvd.test_app' );
					return 'response from method';
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.insertId = true;
			registry.put('test_service', testSrv);
			evt.params = ['testMethod async param'];
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.equal(resp.data, 'response from method');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with data if service exported method was called with params and is async', function(done) {
			var testSrv = {
				testMethod: function(param, cb) { cb(undefined, param); },
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isAsync = true;
			registry.put('test_service', testSrv);
			evt.params = ['testMethod async param'];
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isDefined(resp.data);
				assert.equal(resp.data, 'testMethod async param');
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB without data if service exported method was called without params, dont return anything and is async', function(done) {
			var testSrv = {
				testMethod: function(cb) { cb(); },
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isAsync = true;
			registry.put('test_service', testSrv);
			evt.params = [];
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isUndefined(resp.data);
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB without data if service exported method was called with undefined params, dont return anything and is async', function(done) {
			var testSrv = {
				testMethod: function(cb) { cb(); },
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isAsync = true;
			registry.put('test_service', testSrv);
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isUndefined(resp.data);
				assert.isFalse(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should call resultCB with data if service exported method was called and is a signal', function(done) {
			var testSrv = {
				testMethod: function(param, fn) {
					assert.equal(param, 'Test Event');
					// Simulate emit of signal:
					process.nextTick( function() {fn('Emited data');});
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isSignal = true;
			registry.put('test_service', testSrv);
			evt.params = ['Test Event'];
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isDefined(resp.data);
				assert.equal(resp.data, 'Emited data');
				assert.isTrue(resp.isSignal);
				done();
			};
			evt.unregisterSignal = function() {
				done(new Error('Should not add signal unregister if method dont register one'));
			};
			registry.runAPI(evt);
		});

		it('should fail if signal not allowed', function(done) {
			var testSrv = {
				testMethod: function(param, fn) {
					assert.equal(param, 'Test Event');
					// Simulate emit of signal:
					process.nextTick( function() {fn('Emited data');});
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isSignal = true;
			registry.put('test_service', testSrv);
			evt.params = ['Test Event'];
			evt.resultCB = function(resp) {
				assert.isDefined(resp.error);
				assert.equal(resp.error.message, 'Registry API call cannot be processed; appID=ar.edu.unlp.info.lifia.tvd.test_app, apiID=ar.edu.unlp.info.lifia.tvd.test_service, apiName=undefined, method=testMethod, err=Signals not allowed');
				done();
			};
			evt.unregisterSignal = function() {};
			evt.failOnSignal=true;
			registry.runAPI(evt);
		});

		it('should call resultCB with data if service exported method was called with undefined params and is a signal', function(done) {
			var testSrv = {
				testMethod: function( fn) {
					// Simulate emit of signal:
					process.nextTick( function() {fn('Emited data');});
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isSignal = true;
			registry.put('test_service', testSrv);
			evt.resultCB = function(resp) {
				assert.isUndefined(resp.error);
				assert.isDefined(resp.data);
				assert.equal(resp.data, 'Emited data');
				assert.isTrue(resp.isSignal);
				done();
			};
			registry.runAPI(evt);
		});

		it('should unregister from signal', function(done) {
			var testSrv = {
				testMethod: function(param, fn) {
					assert.equal(param, 'Test Event');
					// Simulate emit of signal:
					process.nextTick( function() {fn('Emited data');});
				},
				getWebAPI: function() {
					return {
						'name': 'testsrv',
						'public': ['testMethod']
					};
				}
			};
			testSrv.testMethod.isSignal = true;
			testSrv.testMethod.unregisterMethod = function(evtName, fn) {
				assert.equal(evtName, 'Test Event');
				// Simulate unregistration
				fn('exit');
			};
			registry.put('test_service', testSrv);
			evt.params = ['Test Event'];
			evt.resultCB = function(resp) {
				if (resp.data[0] === 'exit') {
					// Called from unregisterMethod to simulate unregistration of signal
					done();
				} else {
					assert.isUndefined(resp.error);
					assert.isDefined(resp.data);
					assert.equal(resp.data, 'Emited data');
					assert.isTrue(resp.isSignal);
					unregs.forEach(function(fnc) {fnc();});
				}
			};
			evt.unregisterSignal = function(unregisterFn) {
				unregs.push(unregisterFn);
			};
			var unregs = [];
			registry.runAPI(evt);
		});
	});

	describe( 'composed', function() {
		function runMethod( api, method, result ) {
			return new bPromise(function(resolve) {
				let evt = {
					serviceID: 'some.id',
					apiName: api,
					method: method,
					security: { all: true },
					resultCB: function(resp) {
						assert.isUndefined(resp.error);
						assert.isDefined(resp.data);
						assert.equal( resp.data, result );
						assert.isFalse(resp.isSignal);
						resolve();
					},
					appID: 'ar.edu.unlp.info.lifia.tvd.test_app'
				};

				registry.runAPI( evt );
			});
		}

		it('should add a composed api', function(done) {
			{	//	Put
				let api = {
					method1: function() {
						return 'method1 called';
					},
					subAPI1: {
						method2: function() {
							return 'method2 called';
						},
						getWebAPI: function() {
							return {
								name: 'subAPI1',
								'public': ['method2']
							};
						}
					},
					getWebAPI: function() {
						return {
							name: 'api1',
							modules: ['subAPI1'],
							'public': ['method1']
						};
					}
				};
				registry.put('some.id', api);
				assert.isTrue(registry.has('some.id'));
			}

			{	//	Get
				let rAPI = registry.get('some.id');
				assert.isObject(rAPI);
				assert.isFunction(rAPI.method1);
				assert.isObject(rAPI.subAPI1);
				assert.isFunction(rAPI.subAPI1.method2);
			}

			{	//	getWebApis
				let webAPI = registry.getWebApis( ['some.id'] );
				assert(webAPI);
				assert.equal(webAPI.length, 2 );

				{
					let web = webAPI[0];
					assert.equal( web.name, 'api1' );
					assert.equal( web.id, 'some.id' );
					assert.equal( web.exports.length, 1 );
					assert.equal( web.exports[0], 'method1' );
				}

				{
					let web = webAPI[1];
					assert.equal( web.name, 'api1.subAPI1' );
					assert.equal( web.id, 'some.id' );
					assert.equal( web.exports.length, 1 );
					assert.equal( web.exports[0], 'method2' );
				}
			}

			{	//	runAPI
				runMethod( 'api1', 'method1', 'method1 called' )
					.then( () => runMethod( 'api1.subAPI1', 'method2', 'method2 called' ) )
					.then( () => done() );
			}
		});
	});
});
