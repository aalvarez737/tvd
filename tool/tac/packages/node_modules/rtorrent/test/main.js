'use strict';

var _ = require('lodash');
var os = require('os');
var tvdutil = require('tvdutil');
var path = require('path');
var fs = require('fs');
var chai = require('chai');
chai.config.includeStack = true;
var bPromise = require('bluebird');
var mktemp = bPromise.promisifyAll( require('mktemp') );
var assert = chai.assert;
var Mocks = require('mocks');

var Parser = require('../src/parser');

var originalRequireFn = module.constructor.prototype.require;
var customParser = null;
var customExport = function() {
	if (customParser) {
		return customParser();
	}
	return new Parser();
};
module.constructor.prototype.require = function(p) {
	var self = this;
	if (p === './parser') {
		return customExport;
	}
	return self.constructor._load(p, self);
};

var Rtorrent = require('../src/main');

describe('rtorrent', function() {
	var reg = null;

	beforeEach(function() {
		customParser = null;
		reg = Mocks.init('silly');
	});

	afterEach(function() {
		Mocks.fin();
		reg = null;
	});

	describe( 'constructor', function() {
		it( 'basic', function() {
			var rtorrent = new Rtorrent();
			assert(rtorrent);
		});
	});

	describe( 'methods', function() {
		var linkTorrent = 'http://www.slackware.com/torrents/slackware-14.1-install-d1.torrent';
		var hash = '6F8CD699135B491513E65D967A052A7087750D9C';
		var client = null;

		beforeEach(function() {
			client = Rtorrent( 'localhost', 5001 );
		});

		afterEach(function() {
			client.shutdown();
			client = null;
		});

		describe( 'xmlrpc globals', function() {
			it( 'listMethods', function(done) {
				client.listMethods().then(function(methods) {
					assert( methods.indexOf('get_down_rate') > 0 );
					assert( methods.indexOf('get_up_rate') > 0 );
					done();
				});
			});

			it( 'methodSignature', function(done) {
				client.methodSignature( 'system.api_version' ).then(function(help) {
					assert.equal( help, 'undef' );
					done();
				});
			});

			it( 'methodHelp', function(done) {
				client.methodHelp( 'system.api_version' ).then(function(help) {
					assert.equal( help, 'No help is available for this method.' );
					done();
				});
			});

			it( 'methodCall', function(done) {
				client.methodCall( 'system.capabilities', [] ).then(function(caps) {
					assert.equal( caps['facility'], 'xmlrpc-c' );
					done();
				});
			});
		});

		it( 'get globals', function(done) {
			client.getGlobals().then(function(globals) {
				assert(globals);
				assert.equal( globals['up_rate'], 0 );
				assert.equal( globals['down_rate'], 0 );
				done();
			});
		});

		describe( 'start/stop', function() {
			it( 'load a valid torrent file', function(done) {
				client.start( linkTorrent )
					.delay( 1000 )
					.then( () => client.get( hash ) )
					.then(function(info) {
						assert(info);
						assert.equal( info.hash, hash );
						assert.equal( info.size, 702626180 );
						assert.equal( info.open, 1 );
						assert.equal( info.active, 0 );
						client.stop( hash, true ).then(done);
					});
			});
		});

		describe( 'queries', function() {
			beforeEach(function(done) {
				client.start( linkTorrent )
					.delay(1000)
					.then(done);
			});

			afterEach(function(done) {
				client.stop( hash, true ).then(done);
			});

			it( 'getAll', function(done) {
				client.getAll().then(function(torrents) {
					assert.equal( torrents.length, 1 );
					assert.equal( torrents[0].hash, hash );
					done();
				});
			});

			it( 'getTrackers', function(done) {
				client.getTrackers( hash ).then(function(tracks) {
					assert( tracks.length > 0 );
					done();
				});
			});

			it( 'getFiles', function(done) {
				client.getFiles( hash ).then(function(files) {
					assert( files.length > 0 );
					done();
				});
			});

			it( 'getPeers', function(done) {
				client.getPeers( hash ).then(function(peers) {
					assert.equal( peers.length, 0 );
					done();
				});
			});
		});

		describe( 'serialize/deserialize', function() {
			it( 'test serialize a boolean (true)', function(done) {
				client.methodCall( 'system.capabilities', [true] ).catch(function(err) {
					assert(err);
					done();
				});
			});

			it( 'test serialize a boolean (false)', function(done) {
				client.methodCall( 'system.capabilities', [false] ).catch(function(err) {
					assert(err);
					done();
				});
			});

			it( 'test serialize a number (integer)', function(done) {
				client.methodCall( 'system.capabilities', [10] ).catch(function(err) {
					assert(err);
					done();
				});
			});

			it( 'test serialize a number (double)', function(done) {
				client.methodCall( 'system.capabilities', [10.2] ).catch(function(err) {
					assert(err);
					done();
				});
			});

			it( 'test serialize a object (null)', function(done) {
				client.methodCall( 'system.capabilities', [null] ).catch(function(err) {
					assert(err);
					done();
				});
			});

			it( 'test serialize a date', function(done) {
				client.methodCall( 'system.capabilities', [new Date(1000)] ).catch(function(err) {
					assert(err);
					assert.equal(err.message, 'Cannot parse Date arguments');
					done();
				});
			});

			it( 'test serialize a function', function(done) {
				client.methodCall( 'system.capabilities', [function() {}] ).catch(function(err) {
					assert(err);
					assert.equal(err.message, 'Invalid type of argument: function');
					done();
				});
			});

			it( 'call some method and handle some error', function(done) {
				customParser = function() {
					var self = {};
					self.deserialize = function(res,cb) {
						cb( new Error('Alguno') );
					};
					return self;
				};

				client.getGlobals().catch(function(err) {
					assert(err);
					assert.equal( err.message, 'Alguno' );
					done();
				});
			});
		});
	});
});

